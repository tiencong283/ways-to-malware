#include <Windows.h>
#include "resource.h"
#include <time.h>
#include <cstdio>

int delta = 2;
struct ballInfoStruct {
	int x;	// x coordinate
	int y;	// y coordinate
	int dx;	// x delta
	int dy;	// y delta
	int width;	// width of the ball
	int height;	// height of the ball
} ballInfo;

HBITMAP hbmBall = NULL;
int frameFrqTimer = 0;
int frameFrq = 5; // miliseconds/one frame n

// messages
const char* errStr = "ERROR";
// main
const char* userWndClassName = "ForTextReverseWndClass";
const char* wndTitle = "ASM #14 - Boucing Ball";
const char* regClassFail = "Cannot register the window class";
const char* createWndFail = "Cannot create the window";

void __declspec(naked) __stdcall customZeroMem(char* mem, int size) {
	__asm {
		push ebp
		mov ebp, esp

		// memset(mem, 0 , size)
		mov edi, dword ptr[ebp + 0x8]
		xor al, al
		mov ecx, dword ptr[ebp + 0xc]
		rep stosb

		leave
		ret 8	// restore stack for args
	}
}

void  __declspec(naked) __stdcall updateBallInfo(RECT* clientRecP) {
	__asm {
		push ebx
		push esi
		push edi
		push ebp
		mov ebp, esp
		sub esp, 0x10

		mov ebx, OFFSET ballInfo

		mov eax, dword ptr[ebx + 0x8]
		add eax, dword ptr[ebx]
		mov dword ptr[ebx], eax	// ballInfo.x += ballInfo.dx
		mov edi, eax

		test edi, edi
		js updateDX
		mov eax, dword ptr[ebp + 0x14]
		mov eax, dword ptr[eax + 0x8]	// clientRecP->right
		sub eax, dword ptr[ebx + 0x10]	// clientRecP->right - ballInfo.width
		cmp edi, eax
		jge updateDX
		jmp dyTest
updateDX:
		mov eax, dword ptr[ebx + 0x8]
		not eax	
		inc eax
		mov dword ptr[ebx + 0x8], eax	// ballInfo.dx *= -1
dyTest:
		mov eax, dword ptr[ebx + 0xc]
		add eax, dword ptr[ebx + 0x4]
		mov dword ptr[ebx + 0x4], eax	// ballInfo.y += ballInfo.dy
		mov edi, eax

		test edi, edi
		js updateDY
		mov eax, dword ptr[ebp + 0x14]
		mov eax, dword ptr[eax + 0xc]	// clientRecP->bottom
		sub eax, dword ptr[ebx + 0x14]	// clientRecP->bottom - ballInfo.height
		cmp edi, eax
		jge updateDY
		jmp updateBallInfoRet
updateDY :
		mov eax, dword ptr[ebx + 0xc]
		not eax
		inc eax
		mov dword ptr[ebx + 0xc], eax	// ballInfo.dy *= -1
	}
	__asm {
updateBallInfoRet:
		leave
		pop edi
		pop esi
		pop ebx
		ret 4
	}
}

void __declspec(naked) __stdcall drawBall(RECT* clientRecP, HDC hdc) {
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x20

		/*
			ebp - 0x4	: hdcMem
			ebp - 0x8	: hbmOld
		*/

		mov eax, COLOR_WINDOW	// a color value instead of a handle to a logical brush 
		inc eax	// the value 1 must be added to the chosen color
		push eax
		push dword ptr[ebp + 0x8]
		push dword ptr[ebp + 0xc]
		call FillRect

		push dword ptr[ebp + 0xc]
		call CreateCompatibleDC
		test eax, eax
		jz drawBallRet
		mov dword ptr[ebp - 0x4], eax

		push hbmBall
		push eax
		call SelectObject
		mov dword ptr[ebp - 0x8], eax
		
		push 0x00CC0020	// SRCCOPY
		push 0
		push 0
		push dword ptr[ebp - 0x4]
		mov eax, OFFSET ballInfo
		push dword ptr[eax + 0x14]
		push dword ptr[eax + 0x10]
		push dword ptr[eax + 0x4]
		push dword ptr[eax]
		push dword ptr[ebp + 0xc]
		call BitBlt	// BitBlt(hdc, ballInfo.x, ballInfo.y, ballInfo.width, ballInfo.height, hdcMem, 0, 0, SRCCOPY)

		push dword ptr[ebp - 0x8]
		push dword ptr[ebp - 0x4]
		call SelectObject
		
		push dword ptr[ebp - 0x4]
		call DeleteDC
	}
	__asm {
drawBallRet:
		leave
		ret 8
	}
}

LRESULT __declspec(naked) __stdcall  WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	__asm {
		push ebx
		push esi
		push edi
		push ebp
		mov ebp, esp
		sub esp, 0x100
	}
	/*
		. ebp + 0x14 -> first argument hwnd
			size of rect 0x10
			size of BITMAP 0x18
		. ebp - 0x10	// clientRect
		. ebp - 0x28	// bitmap
		. ebp - 0x2c	// rx
		. ebp - 0x30	// ry

		typedef struct tagRECT
		{
			LONG    left;
			LONG    top;
			LONG    right;	0x8
			LONG    bottom;	0xc
		}

		typedef struct tagBITMAP
		{
			LONG        bmType;
			LONG        bmWidth;	0x4
			LONG        bmHeight;	0x8
			LONG        bmWidthBytes;
			WORD        bmPlanes;
			WORD        bmBitsPixel;
			LPVOID      bmBits;
		}
			size of PAINTSTRUCT 0x40
		. ebp - 0x40	// PAINTSTRUCT ps

	*/
	__asm {
		mov ebx, dword ptr[ebp + 0x18]	// uMsg
		cmp ebx, WM_CLOSE
		jz closeL
		cmp ebx, WM_DESTROY
		jz destroyL
		cmp ebx, WM_CREATE
		jz createL
		cmp ebx, WM_PAINT
		jz paintL
		cmp ebx, WM_TIMER
		jz timerL

		push dword ptr[ebp + 0x20]
		push dword ptr[ebp + 0x1c]
		push dword ptr[ebp + 0x18]
		push dword ptr[ebp + 0x14]
		call DefWindowProc

		jmp winprocRet
createL: 
		push IDB_BITMAP_BALL	// boucing ball ID
		push 0
		call GetModuleHandle
		push eax	// hModule
		call LoadBitmap
		mov hbmBall, eax
		test eax, eax
		jnz LoadBitmapOK
		// future use
		jmp winprocRet
LoadBitmapOK:
		lea ebx, [ebp - 0x10]
		push 0x10
		push ebx
		call customZeroMem
		push ebx
		push dword ptr[ebp + 0x14]
		call GetClientRect
		test eax, eax
		jnz GetClientRectOK
		// future use
		jmp winprocRet
GetClientRectOK:
		lea eax, [ebp - 0x28]
		push eax
		push 0x18
		push hbmBall
		call GetObject
	
		push 0
		call time
		push eax
		call srand

		push 0x18
		mov eax, offset ballInfo
		push eax
		call customZeroMem

		call rand
		mov dword ptr[ebp - 0x2c], eax	// rx
		call rand
		mov dword ptr[ebp - 0x30], eax	// ry

		mov ecx, dword ptr[ebp - 0x08]	//	 clientRec.right
		mov eax, dword ptr[ebp - 0x2c]	
		cdq	// expand to edx
		idiv ecx
		mov dword ptr[ballInfo], edx	// ballInfo.x = rx % clientRec.right

		mov ecx, dword ptr[ebp - 0x4]	//	 clientRec.bottom
		mov eax, dword ptr[ebp - 0x30]
		cdq
		idiv ecx
		mov dword ptr[ballInfo + 0x4], edx	// ballInfo.y = ry % clientRec.bottom
	
		mov eax, dword ptr[ebp - 0x24]
		mov dword ptr[ballInfo + 0x10], eax	//	ballInfo.width = bm.bmWidth

		mov eax, dword ptr[ebp - 0x20]
		mov dword ptr[ballInfo + 0x14], eax	// ballInfo.height = bm.bmHeight
		
		mov eax, dword ptr[ebp - 0x2c]
		and eax, 0x1
		test eax, eax
		jz rxEven
		mov edi, 0x1
		jmp rxDone
rxEven:
		mov edi, 0xFFFFFFFF
rxDone:
		mov eax, dword ptr[ebp - 0x30]
		and eax, 0x1
		test eax, eax
		jz ryEven
		mov esi, 0x1
		jmp ryDone
ryEven :
		mov esi, 0xFFFFFFFF
ryDone :
		mov eax, delta
		imul edi
		mov dword ptr[ballInfo + 0x8], eax	// ballInfo.dx = rx * delta;
			
		mov eax, delta
		imul esi
		mov dword ptr[ballInfo + 0xc], eax	// ballInfo.dy = ry * delta;

		push 0
		push frameFrq
		push 0
		push dword ptr[ebp + 0x14]
		call SetTimer
		mov frameFrqTimer, eax
		jmp winprocRet
paintL:
		push 0x40
		lea ebx, [ebp - 0x40]
		push ebx
		call customZeroMem
		push ebx
		push dword ptr[ebp + 0x14]
		call BeginPaint
		
		push eax	// hdc
		lea eax, [ebp - 0x38]	// &ps.rcPaint
		push eax
		call drawBall
		lea eax, [ebp - 0x40]
		push eax
		push dword ptr[ebp + 0x14]
		call EndPaint
		jmp winprocRet
timerL:
		lea ebx, [ebp - 0x10]	// RECT clientRec
		push ebx
		push dword ptr[ebp + 0x14]
		call GetClientRect
		test eax, eax
		jz winprocRet
		
		push ebx
		call updateBallInfo

		push dword ptr[ebp + 0x14]
		call GetDC
		push eax
		push ebx
		call drawBall

		jmp winprocRet
destroyL:
		push 0
		call PostQuitMessage
		xor eax, eax
		jmp winprocRet
closeL:
		
		mov eax, hbmBall
		push eax
		call DeleteObject

		mov eax, frameFrqTimer
		push eax
		push dword ptr[ebp + 0x14]
		call KillTimer

		push dword ptr[ebp + 0x14]
		call DestroyWindow
		xor eax, eax
		jmp winprocRet
winprocRet:
		leave
		pop edi
		pop esi
		pop ebx
		ret
	}
}

int __declspec(naked) __stdcall WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x100
	}
	/*
			sizeof(wndClass) = 0x28
		ebp - 0x28 -> wndClass
		ebp - 0x2c -> hwnd
			sizeof(MSG) = 0x1c
		ebp - 0x50 -> msg
	*/
	__asm {
		lea ebx, dword ptr[ebp - 0x28]
		push 0x28
		push ebx
		call customZeroMem
		
		// wndclass
		mov eax, dword ptr[ebp + 0x8]	// hInstance
		mov dword ptr[ebx + 0x10], eax
		mov eax, userWndClassName
		mov dword ptr[ebx + 0x24], eax	// window class name
		mov eax, WindowProc
		mov dword ptr[ebx + 0x4], eax	// winproc

		// register class
		push ebx
		call RegisterClass
		test eax, eax
		jnz regClassOK

		// if register failed
		mov eax, MB_OK
		xor eax, MB_ICONERROR
		push eax
		push errStr
		push regClassFail
		push 0
		call MessageBox
		mov eax, 1
		jmp mainRet
		
regClassOK:
		push 0	// lpParam 
		mov eax, dword ptr[ebp + 0x8]	// hInstance
		push eax	
		push 0	// hMenu
		push 0	// hWndParent
		push 240	// nHeight
		push 320		// nWidth
		push 0x80000000	// y
		push 0x80000000	// x
		push WS_OVERLAPPEDWINDOW	// dwStyle
		push wndTitle	// lpWindowName
		push userWndClassName	// lpClassName
		push 0	// dwExStyle
		call CreateWindowEx
		test eax, eax
		jnz createWndOk

		// if register failed
		call GetLastError
		mov eax, MB_OK
		xor eax, MB_ICONERROR
		push eax
		push errStr
		push createWndFail
		push 0
		call MessageBox
		mov eax, 1
		jmp mainRet

createWndOk:
		mov dword ptr[ebp - 0x2c], eax
		mov ecx, dword ptr[ebp + 0x14]
		push ecx
		push eax	// hWnd
		call ShowWindow

		lea ebx, [ebp - 0x50]
		push 0x1c
		push ebx
		call customZeroMem
getmsgLoop:
		push 0
		push 0
		push 0
		push ebx
		call GetMessage
		cmp eax, 0
		jz mainRet
		push ebx
		call TranslateMessage
		push ebx
		call DispatchMessage
		jmp getmsgLoop
mainRet:
		leave
		ret
	}
}

