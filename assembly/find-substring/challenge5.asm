bits 32 ; target processor mode

; import fucntion 
extern puts
extern printf
extern stdout
extern setbuf
extern strstr

section .text	; text section containing code
global strlen_custom
strlen_custom:
	push ebp
	mov ebp,  esp
	push edi	; save register
	push ebx
	xor eax, eax
	xor ecx, ecx
	dec ecx
	mov edi, [ebp + 0x8]
	repnz scasb
	neg ecx
	sub ecx, 2
	mov eax, ecx
	pop ebx
	pop edi
	leave
	ret

global fgets_custom
fgets_custom:	; (char* buffer, int size)	; reading size characters from stdin
	push ebp
	mov ebp, esp
	
	mov eax, 0x3	; read
	mov ebx, 0	; stdin
	mov ecx, dword[ebp + 0x8] 	;buffer	
	mov edx, dword[ebp + 0xC]	; size
	int 0x80
	mov edi, dword[ebp + 0x8]
	mov esi, dword[ebp + 0xC]
	dec esi
	mov byte[edi + esi], 0	; buffer[size - 1] = null
	push edi
	call strlen_custom
	mov byte[edi + eax - 1], 0 ; buffer[strlen(buffer) -1] = null
	leave
	ret

global main	; int main ... (not static or private in OOP)
main:
	push ebp
	mov ebp, esp
	sub esp, 0x100

	push 0
	push dword[stdout]
	call setbuf		; unbuffered

	push welcome
	call puts

	lea edi, [ebp - 0x65]		; reading s
	xor eax, eax	; memset
	mov ecx, 0x65
	rep stosb
	push s_prompt
	call printf
	
	lea edi, [ebp - 0x65]
	push 0x65
	push edi
	call fgets_custom
	
	lea edi, [ebp - 0x75]		; reading c
	xor eax, eax	; memset
	mov ecx, 0xB
	rep stosb
	push c_prompt
	call printf
	
	lea edi, [ebp - 0x75]
	push 0xB
	push edi
	call fgets_custom

	; print idxs
	mov dword[ebp - 0x100], 0	; numOfOccurs = ebp - 0x100 ; idxArrays = ebp - 0x9C
	lea edi, [ebp - 0x65]
	lea esi, [ebp - 0x75]
	push esi
	call strlen_custom
	mov ebx, eax		; ebx = strlen(c)
	jmp check
doing:
	push esi
	push edi
	call strstr
	test eax, eax
	jz result

	lea ecx, [ebp - 0x65]
	mov edx, eax
	sub edx, ecx

	mov ecx, dword[ebp - 0x100]	; update numOfOccurs	
	mov dword[ebp - 0x9C + ecx*4], edx	; idxArrays[i] = idx
	inc ecx
	mov dword[ebp - 0x100], ecx
	
	mov edi, eax
	add edi, ebx
check:
	test edi, edi
	jnz doing
result:
	mov ecx, dword[ebp - 0x100]
	push ecx
	push int_fmt
	call printf
	
	xor ebx, ebx	; eax = i
	lea edi, [ebp - 0x9C]
	mov esi, dword[ebp - 0x100]
	jmp check_2
doing_2:
	mov eax, dword[edi + ebx*4]
	push eax
	push int_fmt_2
	call printf
	inc ebx
check_2:
	cmp ebx, esi
	jl doing_2
ret:
	push newline
	call printf
	leave
	ret

section .rodata
welcome: db "--- asm #5 ---",0
s_prompt: db "S = ", 0
c_prompt: db "C = ", 0
int_fmt: db "%d", 0xA, 0
int_fmt_2: db "%d", 0x20, 0
newline: db 0xA, 0
