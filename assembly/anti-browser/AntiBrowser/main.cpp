#include <Windows.h>
#include <iostream>

#define BUFSIZE 1024

const wchar_t* browserArfs[] = {
	L"Google Chrome",
	L"Microsoft Edge",
	L"Mozilla Firefox"
};

int timerID = 1;
int interval = 5000; // milliseconds

HWND logEdit = NULL;
HWND aboutButton = NULL;
HWND hiddenButton = NULL;

// return non-zero if the window title param ends with one of string in the browserArfs list
BOOL isBrowserWindow(const wchar_t* wndTitle) {
	return 1;
	int wndTitleLen = wcslen(wndTitle);
	for (int i = 0; i < sizeof(browserArfs) / sizeof(void*); ++i) {
		const wchar_t* check = browserArfs[i];
		int checkLen = wcslen(check);
		if (checkLen <= wndTitleLen) {
			int i = 1;
			while (i <= checkLen && check[checkLen - i] == wndTitle[wndTitleLen - i]) {
				i += 1;
			}
			if (i > checkLen) {
				return 1;
			}
		}
	}
	return 0;
}

BOOL CALLBACK EnumWindowsProc(HWND hwnd, LPARAM lParam) {
	wchar_t buf[BUFSIZE];
	wchar_t logBuf[BUFSIZE];

	memset(buf, 0, BUFSIZE);
	if (GetWindowTextW(hwnd, buf, BUFSIZE - 1) && IsWindowVisible(hwnd) && wcslen(buf)) {
		if (isBrowserWindow(buf)) {	// filter only browser like window

			//MessageBoxW(NULL, buf, L"", MB_ICONINFORMATION);
			// logging
			GetWindowTextW(logEdit, logBuf, BUFSIZE);
			swprintf_s(logBuf, L"%s\r\n[*] %s", logBuf, buf);
			SetWindowTextW(logEdit, buf);

			//DestroyWindow(hwnd);
			//if (IsWindow(hwnd))	// double tap
			//	SendMessage(hwnd, WM_CLOSE, NULL, NULL);
		}
	}
	return TRUE;
}

LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	switch (uMsg)
	{
	// https://docs.microsoft.com/en-us/windows/win32/menurc/wm-command
	case WM_COMMAND:
	{
		if (lParam == (LONG_PTR)aboutButton && HIWORD(wParam) == BN_CLICKED) {
			MessageBox(hwnd, "Win32api & assembly practice\ncongh4@viettel.com.vn", "About", MB_OK | MB_ICONINFORMATION);
		}
		else if(lParam == (LONG_PTR)hiddenButton && HIWORD(wParam) == BN_CLICKED) {
			ShowWindow(hwnd, SW_HIDE);
		}
		break;
	}
	case WM_CREATE:
	{
		RECT cRect;
		timerID = SetTimer(hwnd, timerID, interval, NULL);

		GetClientRect(hwnd, &cRect);
		logEdit = CreateWindowExW(0, L"EDIT", L"",
			WS_CHILD | WS_VISIBLE | WS_VSCROLL | ES_AUTOVSCROLL | ES_MULTILINE | ES_READONLY,
			0, 0, cRect.right, cRect.bottom - 40, hwnd, NULL,
			GetModuleHandle(NULL),
			NULL   
		);

		aboutButton = CreateWindowEx(0, "BUTTON", "About",
			WS_CHILD | WS_VISIBLE,
			cRect.right - 65, cRect.bottom - 30, 60, 25, hwnd, NULL,
			GetModuleHandle(NULL),
			NULL
		);

		hiddenButton = CreateWindowEx(0, "BUTTON", "Hide",
			WS_CHILD | WS_VISIBLE,
			5, cRect.bottom - 30, 60, 25, hwnd, NULL,
			GetModuleHandle(NULL),
			NULL
		);

		if (logEdit == NULL) {
			MessageBox(hwnd, "Cannot create log window", "ERROR", MB_OK | MB_ICONERROR);
		}
		break;
	}
	case WM_PAINT:
	{
		PAINTSTRUCT ps;
		HDC hdc = BeginPaint(hwnd, &ps);

		// All painting occurs here, between BeginPaint and EndPaint.
		FillRect(hdc, &ps.rcPaint, (HBRUSH)(COLOR_WINDOW + 1));

		EndPaint(hwnd, &ps);
		break;
	}
	case WM_TIMER:
	{
		if (!EnumWindows(EnumWindowsProc, NULL)) {
			SetWindowTextW(logEdit, L"ERROR: cannot enum top level windows");
		}
		break;
	}
	case WM_CLOSE:
	{
		KillTimer(hwnd, timerID);
		DestroyWindow(aboutButton);
		DestroyWindow(hiddenButton);
		DestroyWindow(logEdit);
		DestroyWindow(hwnd);
		break;
	}
	case WM_DESTROY:
	{
		PostQuitMessage(0);
		break;
	}
	default:
		return DefWindowProc(hwnd, uMsg, wParam, lParam);
	}
	return 0;
}


int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pCmdLine, int nCmdShow) {

	// Register the window class.
	const char CLASS_NAME[] = "AntiBrowserWndClass";
	WNDCLASS wc = {};

	wc.lpfnWndProc = WindowProc;
	wc.hInstance = hInstance;
	wc.lpszClassName = CLASS_NAME;

	RegisterClass(&wc);

	HWND hwnd = CreateWindowEx(
		0,                              // Optional window styles.
		CLASS_NAME,                     // Window class
		"ASM #16: AntiBrowser",    // Window text
		WS_OVERLAPPEDWINDOW,            // Window style

		// Size and position
		CW_USEDEFAULT, CW_USEDEFAULT, 320, 240,

		NULL,       // Parent window    
		NULL,       // Menu
		hInstance,  // Instance handle
		NULL        // Additional application data
	);

	if (hwnd == NULL)
	{
		return 0;
	}
	ShowWindow(hwnd, nCmdShow);

	MSG msg = { };
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return EXIT_SUCCESS;
}