bits 32		;	32 bit

; import function
extern printf
extern puts
extern malloc

section .text
global base64encode
base64encode:
	push ebp
	mov ebp, esp
	sub esp,  0x100
	
	; + 0x20 -> n
	; + 0x1C -> buffer	
	; + 0x18 -> bufferSize
	; + 0x14 -> len
	; + 0x10 -> input

	mov esi, dword [ebp + 0x8]	; esi = input
	mov [esp + 0x10], esi

	; strlen(input)
	xor ecx, ecx	; ecx = 0
	not ecx		; ecx = 0xFFFFFFFF
	mov eax, 0	; eax = NULL
	repne scasb
	neg ecx
	sub ecx, 2	; ecx = strlen(input)
	mov [esp + 0x14], ecx

	; bufferSize
	mov eax, ecx
	add eax, 2
	cdq		; copies the sign (bit 31) of the doubleword in the EAX register into every bit position in the EDX register
	mov ebx, 3
	idiv ebx 
	imul eax, 4
	mov [esp + 0x18], eax	
	
	; malloc
	inc eax
	mov [esp], eax
	call malloc
	mov dword[esp + 0x1C], eax
	
	; memset
	mov edi,  eax
	mov ecx, dword [esp + 0x18]
	add ecx, 1
	mov eax, 0	
	rep stosb	; memset(buffer, 0, bufferSize + 1)

	; for loop
	mov eax, [esp + 0x14]
	cdq
	mov ebx, 3
	idiv ebx
	imul eax, 3

	mov [esp + 0x20], eax 	; eax = (len/3)*3
	xor ebx, ebx	; i = ebx
	xor edi, edi	; bi = edx
	jmp check
doing:
	; ------------------------------ buffer[bi++] = base64table[input[i] >> 2];
	mov ecx, [esp + 0x10]		; ecx = input
	movzx eax, byte [ecx + ebx]	; eax = input[i], mov 0 extend		
	shr eax, 2

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
	mov esi, [esp + 0x1C]
	mov byte[esi + edi], al	
	inc edi
	
	; ------------------------------ buffer[bi++] = base64table[((input[i] % 4) << 4) + (input[i+1] >> 4)];
	movzx eax, byte [ecx + ebx]
	cdq
	mov esi, 4
	idiv esi	
	shl edx, 4	; edx = input[i] % 4 << 4
	movzx eax, byte [ecx + ebx + 1]
	shr eax, 4
	add eax, edx

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
        mov esi, [esp + 0x1C]
        mov byte[esi + edi], al 
        inc edi
		
	; ------------------------------ buffer[bi++] = base64table[((input[i+1] % 16) << 2) + (input[i+2] >> 6)];
	movzx eax, byte [ecx + ebx + 1]
	cdq
	mov esi, 0x10
	idiv esi	
	shl edx, 2	; edx = input[i] % 16 << 2
	movzx eax, byte [ecx + ebx + 2]
	shr eax, 6
	add eax, edx

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
        mov esi, [esp + 0x1C]
        mov byte[esi + edi], al 
	inc edi


	; ------------------------------ buffer[bi++] = base64table[input[i+2] % 64];
	movzx eax, byte [ecx + ebx + 2]
	cdq
	mov esi, 0x40
	idiv esi	; edx = input[i] % 64	
	mov eax, edx

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
        mov esi, [esp + 0x1C]
        mov byte[esi + edi], al
	inc edi	
 
	; increment counter
	add ebx, 3
check:
	cmp dword[esp + 0x20], ebx
	jg doing
	
; ------------------------------ process last portion of input
	; sub ebx, 3	; i -= 3
	mov eax, dword [esp + 0x14]
	cdq		
	mov esi, 3
	idiv esi	; edx = len % 3
	cmp edx, 1
	jne continue_l
	
	; ------------------------------ buffer[bi++] = base64table[input[i] >> 2];
	mov ecx, [esp + 0x10]		; ecx = input
	movzx eax, byte [ecx + ebx]	; eax = input[i], mov 0 extend		
	shr eax, 2

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
	mov esi, [esp + 0x1C]
	mov byte[esi + edi], al	
	inc edi
	

	; ------------------------------ buffer[bi++] = base64table[((input[i] % 4) << 4) + (input[i+1] >> 4)];
	movzx eax, byte [ecx + ebx]
	cdq
	mov esi, 4
	idiv esi	
	shl edx, 4	; edx = input[i] % 4 << 4
	movzx eax, byte [ecx + ebx + 1]
	shr eax, 4
	add eax, edx

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
        mov esi, [esp + 0x1C]
        mov byte[esi + edi], al 
	inc edi
	
	; '=='

	mov word [esi + edi], '=='

	jmp ret
continue_l:
	cmp edx, 2
	jne ret


	; ------------------------------ buffer[bi++] = base64table[input[i] >> 2];
	mov ecx, [esp + 0x10]		; ecx = input
	movzx eax, byte [ecx + ebx]	; eax = input[i], mov 0 extend		
	shr eax, 2

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
	mov esi, [esp + 0x1C]
	mov byte[esi + edi], al	
	inc edi
	

	; ------------------------------ buffer[bi++] = base64table[((input[i] % 4) << 4) + (input[i+1] >> 4)];
	movzx eax, byte [ecx + ebx]
	cdq
	mov esi, 4
	idiv esi	
	shl edx, 4	; edx = input[i] % 4 << 4
	movzx eax, byte [ecx + ebx + 1]
	shr eax, 4
	add eax, edx

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
        mov esi, [esp + 0x1C]
        mov byte[esi + edi], al 
	inc edi
	

	; ------------------------------ buffer[bi++] = base64table[((input[i+1] % 16) << 2) + (input[i+2] >> 6)];
	movzx eax, byte [ecx + ebx + 1]
	cdq
	mov esi, 0x10
	idiv esi	
	shl edx, 2	; edx = input[i] % 16 << 2
	movzx eax, byte [ecx + ebx + 2]
	shr eax, 6
	add eax, edx

	; buffer[bi ++] = base64table[eax]
	mov al, byte [base64table + eax]
        mov esi, [esp + 0x1C]
        mov byte[esi + edi], al 
	inc edi	

	; '='
	mov byte[esi + edi], '='
	
		
ret:
	mov eax, dword[esp + 0x1C]
	add esp, 0x100
	leave
	ret

section .text	;	stored in .text section
global main	;	to export like public (not private or static)
main:
	push ebp
	mov ebp, esp
	mov eax, dword [ebp + 8]	; eax = argc
	cmp eax, 1
	jg continue		; jump if argc >= 1
	mov edi, [ebp + 0xc]	; edi = argv
	mov edi, [edi]		; edi = argv[0]
	push edi
	push dword arg_missing
	call printf
	jmp fend 		; unconditioal jump
continue:
	mov edi, dword [ebp + 0xc] ; edi = argv
	mov edi, dword [edi + 0x4] ; edi = argv[1]
	push edi
	push input
	call printf	; printf("Usage: %s <input>", argv[1]);
	pop eax
	call base64encode
	push eax
	push output
	call printf	; printf("encoded: '%s'", base64encode(argv[1]);
	
fend:	
	add esp, 0xF
	leave
	ret


section .rodata
base64table: db "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", 0
arg_missing: db "Usage: %s <input>", 0x0A, 0
input: db "string: '%s'", 0x0A, 0
output: db "encoded: '%s'", 0x0A, 0
check_msg: db "check", 0x0A, 0
