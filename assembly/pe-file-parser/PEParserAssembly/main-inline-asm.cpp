#include <Windows.h>
#include <iostream>
#include <io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>

// dos header
const char* dosHeader = "Dos header:";
const char* magic = "magic: 0x%hx\n";
const char* offsetToPeHeaderStr = "offset to PE header: 0x%08x\n";
int offsetToPeHeader = 0;

// nt header
const char* ntHeader = "Nt header:";
const char* signature = "signature: 0x%08x\n";
const char* machine = "machine: 0x%04hx\n";
const char* numOfSectionsS = "numberOfSections: 0x%04hx\n";
const char* chars = "characteristics: 0x%04hx\n";
const char* exe = "-> executable";
const char* dll = "-> dll";
const char* addrTypeStr = "-> bit: %s\n";
const char* bits[] = { "32bit", "64bit" };

int ntHeaderSize = sizeof(DWORD) + sizeof(IMAGE_FILE_HEADER); // optional header due to differ in size
int isExe = 0;
int isDll = 0;
int addrType = 0;	// 1 -> 64

// optional header
int opheadeSize_32 = sizeof(IMAGE_OPTIONAL_HEADER32);
int opheadeSize_64 = sizeof(IMAGE_OPTIONAL_HEADER64);
const char* ohMagic = "optional header magic(0x10b -32bit, 0x20b -64bit, 0x107 -rom image): 0x%04hx\n";
const char* ep = "entrypoint: 0x%08x\n";
const char* codeBase = "offset to the code section: 0x%08x\n";
const char* imageBase = "image base: 0x%016lx\n";
const char* imageBase_32 = "image base: 0x%08x\n";
const char* sectionAlign = "section alignment: 0x%08x\n";
const char* fileAlign = "file alignment: 0x%08x\n";
const char* imageSize = "image size (aligned): 0x%08x\n";
const char* headerSize = "all headers size (offset to first section)(aligned): 0x%08x\n";

// data directories
int numOfDataDir = 0x10;
const char* dr_header = "Data dir:\nindex\tname\trva\tsize";
const char* dr_fmt = "[%02x] \t%10s \t0x%08x \t0x%08x\n";
const char* dr_names[] = {
	"EXPORT",
	"IMPORT",
	"RESOURCE",
	"EXCEPTION",
	"SECURITY",
	"BASERELOC",
	"DEBUG",
	"ARCHITECTURE",
	"GLOBALPTR",
	"TLS",
	"LOAD_CONFIG",
	"BOUND_IMPORT",
	"IAT",
	"DELAY_IMPORT",
	"COM_DESCRIPTOR"
};

// section dir
struct sHeaderInfoType {
	int numOfSections;
	int offset;
} sHeaderInfo;
const char* sHeader = "Section headers: \n";
const int sHeaderEntrySize = 0x28;	// 40 bytes
const char* sh_headers = "index\tname\tvirtual address offset\tsize on mem\tfile address offset\tsize on file\tcharacteristics\tpermissions\n";
const char* sh_fmt = "[%02x] \t%8s \t0x%08x \t0x%08x \t0x%08x \t0x%08x \t0x%08x \t%03s\n";

// import directory
int idRva = 0;
int idOffset = 0;	// import rva (in data dir) - contained section's rva + contained section's raw addr 
const char* id_wc = "Import directory: \n";
const char* id_headers = "index\tmodule_name\tOFTs(import name table rva)\tFTs(import address table rva)\n";
const char* id_fmt = "[%02x] \t%16s \t0x%08x \t0x%08x\n";
const char* if_fmt = "%s, ";
const int if_limit = 5;
const char* if_limit_str = "Note: only print first %d import functions (control by if_limit variable)\n";

// export directory
int epRva = 0;
const char*	ep_wc = "Export directory: \n";
const int epSize = sizeof(IMAGE_EXPORT_DIRECTORY);
const char* ep_name = "dll name: %s\n";
const char* ep_base = "starting ordinal number: 0x%08x\n";
const char* ep_nf = "numberOfFuntions: 0x%08x\n";
const char* ep_nn = "numberOfNames: 0x%08x (maybe != numberOfFuntions due to alias or export by ordinal)\n";
const char* ep_af = "addressOfFunctions: 0x%08x (head of export func RVA's list)\n";
const char* ep_an = "addressOfNames: 0x%08x (head of export func name's list)\n";
const char* ep_ano = "addressOfNameOrdinals: 0x%08x (names[i] ~ export function exportFunc[nameOrdinals[i]])\n";
const char* ep_list = "exported name functions: \n";

// main
const char* usage = "Usage: %s <executable file>\n";
const char* openErrMsg = "ERROR: cannot open file '%s'";
int fileFd = -1;
int dosHeaderSize = 0x40;

void __declspec(naked) printNewline() {
	__asm {
		sub esp, 0x1
		mov byte ptr[esp], 0x0
		push esp
		call puts
		add esp, 0x5
		ret
	}
}
void __declspec(naked)  lseekStart() {	// seek from start
	__asm {
		push SEEK_SET
		push dword ptr[esp + 0x8]
		push fileFd
		call _lseek
		add esp, 0xc
		ret
	}
}

void __declspec(naked) readDosHeader() {
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x40
	}
	/*
		ebp - 0x10	; dosHeaderBuf
	*/
	__asm {
		push dosHeader
		call puts

		push 0x0
		call lseekStart
		push dosHeaderSize
		call malloc
		mov dword ptr[ebp - 0x10], eax

		push dosHeaderSize
		push eax
		push fileFd
		call _read
		mov ebx, dword ptr[ebp - 0x10]	// ebx calle-saved
		mov ax, word ptr[ebx + 0x0] // magic
		cwd
		push ax
		push magic
		call printf

		mov eax, dword ptr[ebx + 0x3c] // offset to pe header
		mov offsetToPeHeader, eax  // offsetToPeHeader
		push eax
		push offsetToPeHeaderStr
		call printf

		push dword ptr[ebp - 0x10]
		call free
	}
	__asm {
		leave
		ret
	}
}

void __declspec(naked) printNtFlags() {
	__asm {
		push ebx
		push ebp
		mov ebp, esp
	}
	__asm {
		mov ebx, dword ptr[esp + 0xc]
		mov eax, ebx
		and eax, IMAGE_FILE_EXECUTABLE_IMAGE // 0x2
		jz exe_done
		mov isExe, 0x1
		push exe
		call puts
		exe_done :
		mov eax, ebx
		and eax, IMAGE_FILE_DLL // 0x2000
		jz dll_done
		mov isDll, 0x1
		push dll
		call puts
		dll_done :
		mov eax, ebx
		and eax, IMAGE_FILE_32BIT_MACHINE // 0x0100
		jnz addrType_done
		mov addrType, 0x1	// 64bit
		addrType_done :
		mov eax, addrType
		mov ebx, 0x4
		imul ebx
		push dword ptr[bits + eax]	// bits contains addresses of strings
		push addrTypeStr
		call printf
	}
	__asm {
		leave
		pop ebx
		ret
	}
}

void __declspec(naked) printDataDir() {
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x10
	}
	/*
		i = [ebp - 0x4]
	*/
	__asm {
		call printNewline
		push dr_header
		call puts

		mov ebx, dword ptr[ebp + 0x8]
		xor eax, eax
		mov dword ptr[ebp - 0x4], eax	// i
pdr_loop:
		cmp eax, numOfDataDir
		jge pdr_leave
		
		mov ecx, dword ptr[ebx]
		mov edx, dword ptr[ebx + 4]
		test edx, edx
		jz pdr_loop_skip
		test eax, eax	// export dir
		jnz save_export_done
		mov epRva, ecx
save_export_done:
		cmp eax, 0x1	// import dir
		jnz save_import_done
		mov idRva, ecx
save_import_done:
		push edx	// size
		push ecx	// rva
		push dword ptr[dr_names + 4*eax]
		push eax	// idx
		push dr_fmt
		call printf
		add esp, 0x14

pdr_loop_skip:
		add ebx, 8	// next entry
		mov eax, dword ptr[ebp - 0x4]
		inc eax
		mov dword ptr[ebp - 0x4], eax
		jmp pdr_loop
	}
	__asm {
pdr_leave:
		leave
		ret
	}
}

void __declspec(naked) readNtHeader() {
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x40
	}
	/*
		ebp - 0x10	; dosNtBuffer	not including optionalHeader
		ebp - 0x14	; optionalHeader
	*/
	__asm {
		call printNewline
		push ntHeader
		call puts
		push offsetToPeHeader
		call lseekStart	// seek to pe header
		push ntHeaderSize
		call malloc
		mov dword ptr[ebp - 0x10], eax

		push ntHeaderSize
		push eax
		push fileFd
		call _read
		mov ebx, dword ptr[ebp - 0x10]	// ebx calle-saved

		// signature, file header
		mov eax, dword ptr[ebx + 0x0]
		push eax
		push signature
		call printf

		movsx eax, word ptr[ebx + 0x4]	// machine
		push eax
		push machine
		call printf

		movsx eax, word ptr[ebx + 0x6]	// numOfSections
		mov dword ptr[sHeaderInfo], eax
		push eax
		push numOfSectionsS
		call printf
		
		movsx eax, word ptr[ebx + 0x14]
		add eax, offsetToPeHeader
		add eax, ntHeaderSize
		mov dword ptr[sHeaderInfo + 0x4], eax	// sHeaderInfo.offset = SizeOfOptionalHeader + offsetToPe + fileHeaderSize + PeSignature

		movzx eax, word ptr[ebx + 0x16]	// characteristics, movzx vs movsx ?
		push eax
		push chars
		call printf

		movzx eax, word ptr[ebx + 0x16]
		push eax
		call printNtFlags

		// optional header
		mov eax, offsetToPeHeader
		add eax, ntHeaderSize
		mov dword ptr[ebp - 0x18], eax
		push eax
		push fileFd
		call _lseek	// seek to start of optional header

		mov eax, addrType
		test eax, eax
		jz optionHeader_32
		// optional header for 64bit  binary
		push opheadeSize_64
		call malloc
		mov dword ptr[ebp - 0x14], eax
		mov ebx, eax	// save to ebx

		push opheadeSize_64
		push dword ptr[ebp - 0x14]
		push fileFd
		call _read
		
		push dword ptr[ebx + 0x0]
		push ohMagic
		call printf

		push dword ptr[ebx + 0x10]	// entry point
		push ep
		call printf

		push dword ptr[ebx + 0x14]	// offset to code section
		push codeBase
		call printf

		push dword ptr[ebx + 0x1c]
		push dword ptr[ebx + 0x18]	// image base
		push imageBase
		call printf

		push dword ptr[ebx + 0x20]	// section alignment
		push sectionAlign
		call printf

		push dword ptr[ebx + 0x24]	// file alignment
		push fileAlign
		call printf

		push dword ptr[ebx + 0x38]	// image size
		push imageSize
		call printf

		push dword ptr[ebx + 0x3c]	// headers size
		push headerSize
		call printf

		// data directories info
		add ebx, 0x70
		push ebx
		call printDataDir

		jmp roh_leave
optionHeader_32 :	// optional header for 32bit  binary
		push opheadeSize_32
		call malloc
		mov dword ptr[ebp - 0x14], eax
		mov ebx, eax	// save to ebx

		push opheadeSize_32
		push dword ptr[ebp - 0x14]
		push fileFd
		call _read

		push dword ptr[ebx + 0x0]
		push ohMagic
		call printf

		push dword ptr[ebx + 0x10]	// entry point
		push ep
		call printf

		push dword ptr[ebx + 0x14]	// offset to code section
		push codeBase
		call printf

		push dword ptr[ebx + 0x1c]	// image base
		push imageBase_32
		call printf

		push dword ptr[ebx + 0x20]	// section alignment
		push sectionAlign
		call printf

		push dword ptr[ebx + 0x24]	// file alignment
		push fileAlign
		call printf

		push dword ptr[ebx + 0x38]	// image size
		push imageSize
		call printf

		push dword ptr[ebx + 0x3c]	// headers size
		push headerSize
		call printf

		// data directories info
		add ebx, 0x60
		push ebx
		call printDataDir

roh_leave :
		push dword ptr[ebp - 0x10]
		call free
		push dword ptr[ebp - 0x14]
		call free
	}
	__asm {
		leave
		ret
	}
}
void __declspec(naked) setSectionFlags() {
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x100
	}
	/*
		ecx = "---" ptr;
	*/
	__asm {
		mov eax, dword ptr[ebp + 0x8]
		and eax, 0x20000000		// IMAGE_SCN_MEM_EXECUTE
		jz s_exe_p
		mov byte ptr[ecx + 2], 0x78
s_exe_p:
		mov eax, dword ptr[ebp + 0x8]
		and eax, 0x40000000		// IMAGE_SCN_MEM_READ
		jz s_read_p
		mov byte ptr[ecx], 0x72
s_read_p:
		mov eax, dword ptr[ebp + 0x8]
		and eax, 0x80000000		// IMAGE_SCN_MEM_WRITE
		jz s_write_p
		mov byte ptr[ecx + 1], 0x77
s_write_p:

	}
	__asm {
		leave
		ret
	}
}

// default is __fastcall 
void __declspec(naked) readSectionHeader() {
	// Naked functions must provide their own prolog...
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x100
	}
	__asm {
		push sHeader
		call printf

		push dword ptr[sHeaderInfo + 4]
		call lseekStart	// seek to offset of 
		// try to use stack mem
		push sh_headers
		call printf

		
		xor ebx, ebx
rsh_loop:
		cmp ebx, dword ptr[sHeaderInfo]
		jge rsh_loop_done

		lea eax, [ebp - 0x28]
		push 0x28
		push eax
		push fileFd
		call read

		lea eax, [ebp - 0x28]
		mov dword ptr[ebp - 0x2c], 0x2d2d2d	// "---"
		lea  ecx, [ebp - 0x2c]
		push dword ptr[eax + 0x24]
		call setSectionFlags

		lea  eax, [ebp - 0x2c]
		push eax	// permission
		
		lea eax, [ebp - 0x28]
		push dword ptr[eax + 0x24]
		push dword ptr[eax + 0x10]	// raw size
		push dword ptr[eax + 0x14]	// raw adr
		push dword ptr[eax + 0x8]	// vsize
		push dword ptr[eax + 0xC]	// rva
		push eax	// name
		push ebx	// idx
		push sh_fmt
		call printf

		// calculate file offset of import dir
		lea eax, [ebp - 0x28]
		mov ecx, dword ptr[eax + 0xC]
		add ecx, dword ptr[eax + 0x8]
		cmp ecx, idRva
		jle	cal_id_raw_done
		mov eax, idOffset
		test eax, eax
		jnz cal_id_raw_done		// idOffset not set and belongs to that section

		mov ecx, idRva
		lea eax, [ebp - 0x28]
		sub ecx, dword ptr[eax + 0xC]
		add ecx, dword ptr[eax + 0x14]
		mov idOffset, ecx
cal_id_raw_done:
		add esp, 0x2c
		inc ebx
		jmp rsh_loop
rsh_loop_done:
	}
	__asm {
		leave
		ret
	}
}

// default is __fastcall 
void __declspec(naked) convertToFileOffset() {
	// Naked functions must provide their own prolog...
	__asm {
		push ebx
		push ebp
		mov ebp, esp
		sub esp, 0x100
	}
	/*	edx -> rva to be converted
		ebp - 0x28 -> section header
	*/
	__asm {
		push dword ptr[sHeaderInfo + 4]
		call lseekStart	// seek to offset of 
		xor ebx, ebx
ctfo_loop :
		cmp ebx, dword ptr[sHeaderInfo]
		jge ctfo_ret

		lea eax, [ebp - 0x28]
		push 0x28
		push eax
		push fileFd
		call read

		// calculate file offset of import dir
		lea eax, [ebp - 0x28]
		mov ecx, dword ptr[eax + 0xC]
		add ecx, dword ptr[eax + 0x8]
		cmp ecx, dword ptr[ebp + 0xc]
		jl ctfo_loop_inc

		mov ecx, dword ptr[ebp + 0xc]
		lea eax, [ebp - 0x28]
		sub ecx, dword ptr[eax + 0xC]
		add ecx, dword ptr[eax + 0x14]
		mov eax, ecx
		jmp ctfo_ret
ctfo_loop_inc:
		inc ebx
		jmp ctfo_loop
	}
	__asm {
ctfo_ret:
		leave
		pop ebx
		ret
	}
}
int __declspec(naked) printImportFunctions() {
	__asm {
		push ebx
		push ebp
		mov ebp, esp
		sub esp, 0x40
	}
	/*
		file offset of OFTs 
		ebp - 0x10	-> rva to fname entry 
		ebp - 0x30	; buf
		ebp - 0x34	; if_limit
	*/
	__asm {
		mov ebx, dword ptr[ebp + 0xc]
		xor edx, edx
		mov dword ptr[ebp - 0x34], edx
pif_loop:
		mov edx, dword ptr[ebp - 0x34]
		cmp edx, if_limit
		jge pif_ret

		push ebx
		call lseekStart

		mov eax, addrType
		cmp eax, 0x1
		jz pif_64
		push 0x4	// for 32bit
		lea eax, [ebp - 0x10]
		push eax
		push fileFd
		call _read
		add ebx, 0x4		// next entry

		jmp pif_remain
pif_64:
		push 0x8			// for 64bit
		lea eax, [ebp - 0x10]
		push eax
		push fileFd
		call _read
		add ebx, 0x8		// next entry
pif_remain:

		mov eax, dword ptr[ebp - 0x10]
		test eax, eax
		jz pif_ret
		push eax
		call convertToFileOffset
		add eax, 0x2	// skip Hint -> name
		push eax
		call lseekStart

		push 0x20
		lea eax, [ebp - 0x30]
		push eax
		push fileFd
		call _read

		lea eax, [ebp - 0x30]
		push eax
		push if_fmt
		call printf

		mov edx, dword ptr[ebp - 0x34]
		inc edx
		mov dword ptr[ebp - 0x34], edx
		jmp pif_loop
	}
	__asm {
pif_ret:
		call printNewline
		leave
		pop ebx
		ret
	}
}
int __declspec(naked) readImportTable() {
	// Naked functions must provide their own prolog...
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x40
	}
	/*
		ebp - 0x20	; import dir entry
		ebp - 0x40	; buffer with size 0x20 
	*/
	__asm {
		call printNewline
		push id_wc
		call printf
		
		push if_limit
		push if_limit_str
		call printf

		xor ebx, ebx
		push id_headers
		call printf
id_loop:
		// how to locate import table
		mov eax, idOffset
		push eax
		call lseekStart

		push 0x14
		lea eax, [ebp - 0x20]
		push eax
		push fileFd
		call _read
		add esp, 0xc
		
		// seek to next entry
		add idOffset, 0x14

		lea eax, [ebp - 0x20]
		mov ecx, dword ptr[eax + 0x10]
		test ecx, ecx
		jz id_loop_done	// break loop
		
		push dword ptr[eax + 0xC]	// name rva
		call convertToFileOffset
		push eax
		call lseekStart

		push 0x20
		lea eax, [ebp - 0x40]
		push eax
		push fileFd
		call _read

		lea eax, [ebp - 0x20]
 		push dword ptr[eax + 0x10]	// ft
		push dword ptr[eax + 0x0]	// oft 
		lea eax, [ebp - 0x40]
		push eax
		push ebx
		push id_fmt
		call printf
		add esp, 0x10

		// list import function names
		lea eax, [ebp - 0x20]
		mov eax, dword ptr[eax + 0x10]	// ft
		push eax
		call convertToFileOffset
		push eax
		call printImportFunctions

		inc ebx
		jmp id_loop
id_loop_done:
	}
	__asm {
		leave
		ret
	}
}

int __declspec(naked) printExportFunctions() {
	__asm {
		push ebx
		push ebp
		mov ebp, esp
		sub esp, 0x50
	}
	/*
		ebp - 0x4	// i
		ebp - 0x10	// value
		ebp - 0x40	// buf
	*/
	__asm {
		call printNewline
		push ep_list
		call printf

		push dword ptr[ebp + 0xc]	// addr of names
		call convertToFileOffset
		mov ebx, eax
		xor ecx, ecx
		mov dword ptr[ebp - 0x4], ecx
pxf_loop:
		cmp ecx, dword ptr[ebp + 0x10]
		jge pxf_leave
		
		push ebx
		call lseekStart
		push 0x4
		lea eax, [ebp - 0x10]
		push eax
		push fileFd
		call _read	// read rva of func name
		add ebx, 0x4

		mov eax, dword ptr[ebp - 0x10]
		push eax
		call convertToFileOffset
		push eax
		call lseekStart
		push 0x30
		lea eax, [ebp - 0x40]
		push eax
		push fileFd
		call _read	// read file offset of func name

		lea eax, [ebp - 0x40]
		push eax
		call printf
		call printNewline

		mov ecx, dword ptr[ebp - 0x4]	// i += 1
		inc ecx
		mov dword ptr[ebp - 0x4], ecx
		jmp pxf_loop
	}
	__asm {
pxf_leave:
		leave
		pop ebx
		ret
	}
}
int __declspec(naked) readExportTable() {
	// Naked functions must provide their own prolog...
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x50
	}
	/*
		ebx = ebp - 0x30	; import dir entry
		ebp - 0x50	; string buffer
	*/
	__asm {
		call printNewline
		push ep_wc
		call printf

		mov eax, epRva
		push eax
		call convertToFileOffset
		push eax
		call lseekStart
		
		lea ebx, [ebp - 0x30]
		push epSize
		push ebx
		push fileFd
		call _read
		
		// print info
		mov ecx, dword ptr[ebx + 0xC]
		push ecx
		call convertToFileOffset	// get dll name offset
		push eax
		call lseekStart

		push 0x20
		lea eax, [ebp - 0x50]
		push eax
		push fileFd
		call _read

		lea eax, [ebp - 0x50]
		push eax
		push ep_name
		call printf	// print dll name
		

		push dword ptr[ebx + 0x10]	// base
		push ep_base
		call printf

		push dword ptr[ebx + 0x14]	// number of functions
		push ep_nf
		call printf

		push dword ptr[ebx + 0x18]	// number of names
		push ep_nn
		call printf

		push dword ptr[ebx + 0x1c]	// addr of functions
		push ep_af
		call printf

		push dword ptr[ebx + 0x20]	// addr of names
		push ep_an
		call printf

		push dword ptr[ebx + 0x24]	// addr of name ordinals
		push ep_ano
		call printf

		push dword ptr[ebx + 0x18]
		push dword ptr[ebx + 0x20]
		call printExportFunctions
	}
	__asm {
		leave
		ret
	}
}

// default is __fastcall 
int __declspec(naked) main(int argc, char** argv) {
	// Naked functions must provide their own prolog...
	__asm {
		push ebp
		mov ebp, esp
		sub esp, 0x40
	}
	/*
		ebp - 0x10	: argv[1]
	*/
	__asm {
		cmp dword ptr[ebp + 0x8], 0x1
		jg argc_p
		; argc
		mov eax, dword ptr[ebp + 0xc]
		push dword ptr[eax]
		push usage
		call printf
		jmp main_leave
		argc_p :
		mov eax, dword ptr[ebp + 0xc]
		mov eax, dword ptr[eax + 0x4]	// argv[1]
		mov dword ptr[ebp - 0x10], eax
		push 0x0
		xor eax, eax
		xor eax, _O_BINARY
		xor eax, _O_RDONLY
		push eax
		push dword ptr[ebp - 0x10]
		call _open
		cmp eax, 0x0
		jns	open_p
		push dword ptr[ebp - 0x10]
		push openErrMsg
		call printf
		jmp main_leave
		open_p :
		mov fileFd, eax
		call readDosHeader	// read dos header
		call readNtHeader	// read nt header
		call readSectionHeader // read section header
		call readImportTable	// read import table
		mov eax, isDll
		test eax, eax
		jz main_close
		call readExportTable	// read export table
main_close:
		mov eax, fileFd
		mov dword ptr[esp], eax
		call _close
	}
	// ... and epilog
	__asm {
	main_leave:
		leave
		ret
	}
}