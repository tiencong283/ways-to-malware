#include <stdio.h>
#include <string.h>
#include <signal.h>
#include <sys/time.h>
#include <unistd.h>
#include <sys/types.h>
#include <dirent.h>
#include <sys/stat.h>
#include <fcntl.h>

#define BUFSIZE 256

int timeout = 10;
const char* procRootPath = "/proc/";

// kill all processes in that list
const char* blackList[] = {
	"man",
	NULL
};

int inBlackList(const char* s){
	const char** bl = blackList;
	while(*bl){
		if (strcmp(s, *bl) == 0)
			return 1;
		bl += 1;	// next entry
	}
	return 0;
}

int isNumericStr(const char* s){
	while(*s){
		char c = *s;
		if (c < '0' || c > '9')
			return 0;
		s += 1;
	}
	return 1;
}
void killProcess(const char* s){
	int processID = atoi(s);
	if (!kill(processID, 0)){	// if active process
		kill(processID, SIGTERM);	// terminate process, kill (1) use it
	}
}
void alarmHandler(int signo){
	struct dirent * de = NULL;
	char	fullpath[BUFSIZE];
	char processName[BUFSIZE];

	DIR* f = opendir(procRootPath);
	if (f == NULL){
		printf("ERROR: cannot read proc snapshot\n");
		return;
	}
	while((de = readdir(f)) != NULL){
		const char* fname = de -> d_name;
		if (strlen(fname) > 0 && fname[0] == '.'){	// ignore hidden files (inclduing ., .. files)
			continue;
		}
		if (!isNumericStr(fname)){
			continue;
		}
		int ret = sprintf(fullpath, "%s/%s/comm", procRootPath, fname);
		fullpath[ret] = '\x00';
		int fd = open(fullpath, O_RDONLY);
		if (fd == -1){
			printf("ERROR: cannot read info of process with ID %s\n", fname);
			continue;
		}
		int rCount = 0;
		if ((rCount = read(fd, processName, BUFSIZE - 1)) == - 1){
			printf("ERROR: cannot read info of process with ID %s\n", fname);
			continue;
		}
		processName[rCount - 1] = '\x00';
		if (inBlackList(processName)){
			printf("[*] killing pname='%s', pid=%s\n", processName, fname);
			killProcess(fname);
		}
		close(fd);
	}
	closedir(f);
}
int main(){
	puts("--- ASM 17: anti-netcat ---");
	struct itimerval timerInfo = {};

	if (signal(SIGALRM, alarmHandler) == SIG_ERR){
		printf("ERROR: cannot associate signal with its handler\n");
		return 1;
	}
	
	timerInfo.it_value.tv_sec = 1;	// first expire will be after timeout seconds after call setitimer
	timerInfo.it_interval.tv_sec = timeout; // for subsequent expires	

	if (setitimer(ITIMER_REAL, &timerInfo, NULL)){
		printf("ERROR: cannot setitimer\n");
		return 1;
	}
	while (1){
		pause();	// caught signal(when alarmHandler) wakes main thread up
	}
	return 0;
}
