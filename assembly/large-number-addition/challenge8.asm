bits 64	

extern fgets
extern stdin
extern stdout
extern puts
extern printf
extern setbuf

section .text
global strlen_custom
strlen_custom:
	push rbp
	mov rbp, rsp

	mov r12, rdi
	mov al, 0x0
	xor rcx, rcx
	dec rcx
	repnz scasb
	sub rdi, r12	
	dec rdi		; rdi = strlen(s) + 1
	
	mov eax, edi
	cdq
	leave
	ret

global remove_newline
remove_newline:
	push rbp
	mov rbp, rsp

	mov r12, rdi
	call strlen_custom
	mov bl, byte[r12 + rax - 1]
	cmp bl,  0xA
	jnz leave
	mov  byte[r12 + rax - 1], 0 	; s[strlen(s) - 1] = null	
leave:
	leave
	ret	

global memset_custom
memset_custom:
		xor al, al
		mov ecx, esi	; rdi = arg1
		rep stosb
		ret

global reverse_str
reverse_str:
	push rbp
	mov rbp, rsp
	mov r12, rdi
	
	call strlen_custom
	mov rbx, rax	; ebx = strlen - 1
	dec rbx
	sar eax, 1	; eax = strlen / 2
	xor rcx, rcx
	jmp check_cond
doing:
	mov r8b, byte[r12  + rcx]	; swap s[i] vs s[strlen(i) - 1 - i]
	mov r9, rbx
	sub r9, rcx
	mov r10b, byte[r12  + r9]
	mov byte[r12  + rcx], r10b
	mov byte[r12  + r9], r8b

	inc ecx
check_cond:
	cmp ecx, eax
	jl doing
	
	leave
	ret
global main
main:
	push rbp
	mov rbp, rsp
	sub rsp, 0x100
	
	mov rdi, welcome
	call printf

	mov rsi, 0
	mov rdi, qword [stdout]
	call setbuf

	lea rdi, [rbp - 0x42]	; n1 = [rbp - 0x16], n2 = [rbp - 0x2C], result = rbp - 0x42
	mov esi, 0x42
	call memset_custom	; memset all that variables
	
	mov rdi, n1_prompt	; n1
	call printf
	mov rdx, qword[stdin]
	mov esi,  0x16
	lea rdi, [rbp - 0x16] ; len(num) = 20 + newline + null
	call fgets
	lea rdi, [rbp - 0x16] 
	call remove_newline	; strip newline
	lea rdi, [rbp - 0x16] 
	call reverse_str	; reverse_str


	mov rdi, n2_prompt	; n2
	call printf
	mov rdx, qword[stdin]
	mov esi,  0x16
	lea rdi, [rbp - 0x2C]	; len(num) = 20 + newline + null
	call fgets
	lea rdi, [rbp - 0x2C] 
	call remove_newline	
	lea rdi, [rbp - 0x2C] 
	call remove_newline	
	lea rdi, [rbp - 0x2C] 
	call reverse_str	; reverse_str
	
	; adding section
	lea  rdi, [rbp - 0x16]	; n1
	lea  rsi, [rbp - 0x2C]	; n2
	lea  r10, [rbp - 0x42]	; result

	xor rcx, rcx
	xor r11d, r11d	; carry
	mov ebx, 0x16
	mov r14, 0xA
	jmp check_cond2
doing2:
	mov r12b, byte [rdi + rcx]
	test r12b, r12b
	jz l1
	sub r12b, 0x30
l1:
	mov r13b, byte [rsi + rcx]
	test r13b, r13b
	jz l2
	sub r13b, 0x30
l2:
	add r13b, r12b
	add r13b, r11b	; + carry

	movzx rax, r13b
	xor rdx, rdx
	idiv r14		; rax = / ; rdx = %

	add dl, 0x30	
	mov byte[r10 + rcx], dl
	mov r11, rax	
	inc ecx
check_cond2:
	cmp ecx,ebx	
	jl doing2
	
	mov r12, r10
	mov byte[r12 + 0x14], 0
	mov rdi, r12
	call reverse_str

	mov rsi, r12
	mov rdi,result_prompt 
	call printf

	leave
	ret

section .rodata
welcome: db "--- asm #1 big number addition (20 digits) ---", 0xA, "-- unchecked input ---", 0xA, 0
n1_prompt: db "n1 = ", 0x0
n2_prompt: db "n2 = ", 0x0
result_prompt: db "   = %s", 0xA, 0
